{
    "Introduction": {
        "Purpose and Scope": "Purpose\n- usbf_top integrates a complete USB 2.0 device function core around a UTMI PHY front-end, a standards-compliant protocol engine, a per-endpoint register/interrupt/DMA block, a single-port external SRAM packet buffer, and a Wishbone slave for software control and SRAM access. It provides a reusable device-side IP that implements all on-the-wire USB 2.0 transaction handling for Full- and High-Speed operation.\n\nScope\n- Functionality\n  - Device-side USB 2.0 link/transaction handling for EP0 (control) and a configurable set of additional endpoints (this build: EP0–EP3).\n  - UTMI interface management: attach detection, bus reset, suspend/resume (including device-initiated remote wake), and HS negotiation; drives XcvSelect/TermSel/OpMode/SuspendM and bridges clean byte-wide RX/TX to the core.\n  - Protocol execution: token/PID decode, CRC5/CRC16 check/generation, IN/OUT/SETUP transaction control, data-toggle selection, HS features (PING/NYET), timeouts, and error/reporting.\n  - Data movement: internal DMA bridge for byte↔32-bit word packing to a shared external synchronous SRAM; fixed-priority arbiter multiplexes USB core vs. Wishbone software accesses.\n  - Software control: Wishbone B3-style slave exposes global status/control, per-endpoint CSRs/interrupts/buffer descriptors, UTMI vendor sideband, and a memory window to the packet SRAM.\n  - Interrupts and DMA: per-endpoint DMA request/ack vectors and two aggregated interrupt outputs (inta_o/intb_o) with maskable RF- and EP-level sources.\n- Interfaces and boundaries\n  - External UTMI PHY: 8-bit DataIn/Out with TxValid/Ready, RxValid/Active/Error, XcvSelect, TermSel, SuspendM, OpMode[1:0], LineState[1:0], usb_vbus, and vendor VControl/VStatus sideband.\n  - External synchronous single-port SRAM: 32-bit data bus; size parameterized by SSRAM_HADR; used as the packet buffer store.\n  - Wishbone slave (clk_i): classic, single-beat accesses to RF (control/status) and MA (SRAM window); single-cycle ACK generation in wb_clk.\n  - System signals: inta_o/intb_o, dma_req_o/dma_ack_i per endpoint, susp_o (reported suspend), resume_req_i (remote wake request input).\n- Clocks, reset, and CDC\n  - Two clock domains: phy_clk_pad_i for UTMI/protocol/memory/CSR core view; clk_i for Wishbone/bus view and exported suspend.\n  - Synchronous resets by default; optional async reset via build define.\n  - All clock-domain crossings are contained within submodules (utmi_if, pl, mem_arb, rf, wb) with clean one-shot/edge techniques for handshakes and ACKs.\n- Configurability\n  - Number of endpoints (EP1..EP15 optional; EP0 always present), address widths, SRAM size/addressing, PID/timeouts, and RF/MEM decode bit are build-time parameters.\n- Intended use\n  - Drop-in device controller IP for ASIC/FPGA SoCs. Firmware configures function address, endpoint CSRs, buffer descriptors, interrupt masks, and may read/write the packet SRAM via Wishbone. Suitable for FS/HS control/bulk/interrupt/iso endpoints with external UTMI PHY and external SRAM.\n- Assumptions and limitations\n  - Requires a UTMI-compliant PHY and a single-port synchronous 32-bit SRAM.\n  - Arbiter gives hard priority to the USB datapath; software SRAM accesses are best-effort when the core is idle.\n  - Chapter 9 request handling, descriptor content, and higher-level class behavior are provided by software; hub/host/OTG roles are out of scope.\n  - This build enables EP0–EP3; endpoints must be contiguous. Some HS certification test modes and certain strict control-pipe corner cases may rely on firmware or be outside the RTL’s scope.",
        "Features and Capabilities": "Features and Capabilities\n- USB 2.0 device function core\n  - Full-Speed and High-Speed operation via UTMI PHY\n  - HS negotiation (chirp detect/count), attach debounce, bus reset detect, suspend/resume, device-initiated remote wake\n  - UTMI control pin driving: XcvSelect, TermSel, OpMode[1:0], SuspendM; vendor sideband bridge (VControl[3:0]/Load, VStatus[7:0])\n- Protocol and link layer\n  - Token/PID decode with complement validation; CRC5 (tokens) and CRC16 (data) check/generation\n  - IN/OUT/SETUP transactions with handshake generation (ACK/NACK/STALL/NYET in HS)\n  - Data PID sequencing (DATA0/1/2/MDATA), zero-length packet support\n  - HS features: PING handling and NYET responses\n  - Timeouts and error detection: ACK wait, data inactivity, unexpected PID, sequence errors, CRC errors, token-not-for-this-function\n  - SOF reception with frame/microframe/subframe timestamp export (frm_nat)\n- Endpoints and buffering\n  - EP0 always present; EP1..EP15 build-time enable (this build: EP0–EP3)\n  - Per-EP CSR configuration: direction, endpoint number, max packet size, DMA enable, policy bits (small/large OK), STALL\n  - Dual buffer descriptors per EP (BUF0/BUF1) with address/size and write-back updates; ping-pong operation\n  - Per-EP status/flags for data availability/space (dma_in_buf_sz1, dma_out_buf_avail)\n- Data movement and memory\n  - Internal DMA bridge (byte↔32-bit word) with RMW on unaligned RX, partial-word flush, and 2-word TX prefetch\n  - Shared external synchronous single-port SRAM (32-bit) for packet buffers; size parameterized by SSRAM_HADR\n  - Fixed-priority SRAM arbiter: protocol/DMA master has hard priority over Wishbone; read data broadcast to both masters\n- Software interface (Wishbone B3-style)\n  - RF region: global registers (main_csr, function address, interrupt masks/sources, frm_nat, UTMI vendor access), per-EP windows (CSR/INT/BUF0/BUF1)\n  - MA region: direct 32-bit window into packet SRAM\n  - Clean, single-cycle ACK in wb_clk; single-transaction sequencing and simple CDC for ACK return\n- Interrupts and DMA\n  - Two aggregated interrupt outputs (inta_o, intb_o) with independent mask sets for RF-level stickies and per-EP causes\n  - Per-EP sticky causes: buffer ready/release, CRC16 error, timeout, unexpected PID, sequence error, HS OUT short (out_to_small)\n  - Per-EP DMA request/ack handshake exported (dma_req_o[15:0], dma_ack_i[15:0])\n- Power and clocking\n  - Dual clock domains: phy_clk for UTMI/protocol/memory core view; clk_i for Wishbone/bus view\n  - Synchronous resets by default (optional async define); CDC contained within submodules\n  - Exposed suspend state (susp_o) and remote-wakeup request path from software\n- Diagnostics and observability\n  - Live link state in main_csr (suspend, HS/FS, attached, line state)\n  - SOF-based timing snapshot (frm_nat)\n  - Latched UTMI vendor status; vendor control write with load strobe\n- Configurability\n  - Compile-time selection of enabled endpoints, address widths, SRAM size (SSRAM_HADR), RF/MEM decode bit, PID/timeout constants\n- Known non-goals/omissions (for clarity)\n  - Wishbone pipelining/bursts/byte-selects not implemented (classic single-beat)\n  - Memory arbiter is fixed-priority (no fairness to Wishbone when USB is active)",
        "Standards Compliance": "Standards Compliance\n- USB 2.0 (device) — Partial compliance\n  - Implemented/Aligned behaviors\n    - FS and HS device operation over UTMI/UTMI+ PHY interface\n    - PID format/validation; CRC5 (token) and CRC16 (data) generation/checking per USB 2.0\n    - Token/data/handshake sequencing for IN/OUT/SETUP; data PID toggle management (DATA0/1/2/MDATA)\n    - Flow control: NAK handling; HS-specific PING acceptance and NYET responses\n    - SOF reception with frame/microframe timing snapshot (frm_nat)\n    - Suspend/resume including device-initiated remote wake; HS chirp negotiation; attach debounce; bus reset detection\n    - Endpoint MaxPacketSize-based policy checks and descriptor-driven transfers\n    - Protocol timeouts for ACK wait and data activity (FS/HS counters)\n  - Not fully compliant / known gaps for certification\n    - EP0 Chapter 9 control-pipe guarantees not fully enforced in RTL (e.g., SETUP must always be accepted and override halt; exact 8-byte SETUP enforcement; correct STALL/Status recovery; DATA0 re-init; auto-clear halt semantics)\n    - Overlength control OUT handling (NAK vs required STALL)\n    - Address reset to 0 on bus reset not explicitly guaranteed in hardware\n    - HS Test Modes (SetFeature(TEST_MODE): Test_J, Test_K, Test_SE0_NAK, Test_Packet, etc.) not implemented\n    - Some ISO/INT specifics (e.g., bInterval enforcement, high-bandwidth multi-transactions per microframe) not enforced in RTL\n  - Implication: Likely interoperable for FS/HS control/bulk/interrupt with appropriate firmware, but not certification-ready without RTL updates noted above.\n- UTMI/UTMI+ PHY Interface\n  - Uses standard UTMI signals and modes (DataIn/Out[7:0], TxValid/Ready, RxValid/Active/Error, XcvSelect, TermSel, OpMode[1:0], SuspendM, LineState[1:0])\n  - Implements link behaviors (attach debounce, reset detect, suspend/resume, HS chirp) and drives UTMI control pins accordingly\n  - Electrical/timing compliance is delegated to the external UTMI/UTMI+ PHY (this core follows the logical/protocol aspects)\n  - Vendor sideband (VControl/VStatus) supported (implementation is PHY-specific/optional)\n- Wishbone Interconnect — Compliant with Wishbone B.3 (classic) slave\n  - Base signal set and classic single-termination handshake (ACK only), single-beat transfers\n  - 32-bit word-aligned addressing; synchronous ACK pulse generation in wb_clk\n  - No B4 features (no bursts, pipelining/STALL, byte-selects, ERR/RTY, tags)\n  - CDC caveat: safest when wb_clk == phy_clk; otherwise system-level timing/CDC measures required\n- Other interfaces\n  - External synchronous single-port SRAM interface is vendor-neutral, not a formal standard; fixed-priority arbiter behavior is defined\n  - CRC modules implement standard USB polynomials (CRC5: x^5+x^2+1; CRC16: x^16+x^15+x^2+1, LSB-first)\n- Compliance summary\n  - Closest protocol match: USB 2.0 device — Partial\n  - Bus interface: Wishbone B.3 classic — Yes; Wishbone B.4 — No",
        "External Dependencies and Assumptions": "External Dependencies and Assumptions\n- UTMI/UTMI+ PHY\n  - Requires an external UTMI/UTMI+ 8-bit PHY providing: DataIn/Out[7:0], TxValid/TxReady, RxValid/RxActive/RxError, LineState[1:0], usb_vbus, and control pins XcvSelect, TermSel, OpMode[1:0], SuspendM.\n  - Electrical signaling, HS/FS analog behavior, and USB eye/timing compliance are the PHY’s responsibility; the core implements protocol/link logic only.\n  - SuspendM polarity and OpMode encodings must match UTMI spec (core assumes standard UTMI semantics).\n  - Vendor sideband VControl[3:0]/VControl_Load and VStatus[7:0] are optional; connect only if the PHY exposes them.\n  - phy_clk_pad_i must match timing constants compiled into the design (e.g., counters use ~250 ns ticks). Set build-time timing defines to the actual PHY clock.\n- System clocks and reset\n  - Two independent clock domains: phy_clk_pad_i (USB core/PHY/memory arbiter) and clk_i (Wishbone/bus view). Resets are synchronous by default; define USBF_ASYNC_RESET if using async reset.\n  - CDC assumptions: Wishbone front-end is safest when wb_clk == phy_clk; if different, the system must ensure CDC safety beyond the provided simple ACK edge synchronizer.\n- External synchronous SRAM\n  - Single-port, 32-bit data width, synchronous SRAM interface: sram_adr_o[SSRAM_HADR:0], sram_data_i/o[31:0], sram_we_o, sram_re_o (tied high by core).\n  - No per-transfer ready/acknowledge is provided at the SRAM pins; read data must be valid per the SRAM’s synchronous timing. If the target SRAM requires additional control/latency, integrate a wrapper outside this core.\n  - Core performs read-modify-write internally for unaligned RX starts and partial tails; byte enables are not provided externally (full 32-bit writes on sram_we_o).\n  - SSRAM_HADR must reflect the actual memory depth; effective buffer size = 4 × 2^(SSRAM_HADR+1) bytes (word addressing with extra align bit).\n- Wishbone interconnect (host/CPU)\n  - Classic Wishbone B.3 single-beat slave only (no bursts, no STALL/PIPE, no SEL/ERR/RTY/tags). Provide wb_addr_i, wb_data_i/o, wb_we_i, wb_stb_i, wb_cyc_i; the core generates a one-cycle wb_ack_o.\n  - Address map split via wb_addr_i[17] (with USBF_TEST_IMPL): 0=Register File (RF), 1=Memory Array (SRAM window). Integrators must ensure consistent SoC decode.\n  - Read data must be sampled on ACK; no back-to-back pipelined cycles are supported.\n- DMA handshakes (system-level)\n  - The RF aggregates per-endpoint dma_req_o[15:0] and expects corresponding dma_ack_i[15:0] from a system DMA or software shim if used. If no external DMA is implemented, disable endpoint DMA (csr.dma_en=0) or ensure dma_ack_i behavior is benign.\n- Firmware/software responsibilities\n  - Chapter 9 control flows and descriptors (enumeration, standard/class/vendor requests) are implemented in software; RTL does not enforce all EP0 rules (e.g., SETUP override-halt, exact 8-byte SETUP, STALL/Status recovery, DATA0 re-init, HS Test Modes).\n  - Program function address, per-EP CSR (direction, max packet, policy bits), and buffer descriptors (BUF0/BUF1). Handle interrupts (inta_o/intb_o) and service/rotate buffers.\n  - Optional: use MAIN_CSR write pulse for device-initiated resume (remote wake). Use UTMI vendor port if the PHY supports it.\n- Integration constraints and priorities\n  - usbf_mem_arb gives hard priority to the USB core (M-side); Wishbone (W-side) SRAM accesses are best-effort and may stall under USB load.\n  - Endpoints must be configured as a contiguous set starting at EP0; build-time macros (USBF_HAVE_EPx) must reflect the intended presence.\n  - Address/width parameters (USBF_UFC_HADR, SSRAM_HADR) must be set consistently across the SoC.\n- Data ordering and alignment\n  - USB byte streams are LSB-first; CRC5 (x^5+x^2+1) and CRC16 (x^16+x^15+x^2+1) logic assumes LSB-first order.\n  - External SRAM accesses are 32-bit word-based; unaligned starts and partial words are handled by the core’s RMW path; no external byte-lane controls required.\n- Power/link assumptions\n  - usb_vbus must reflect real VBUS state for proper attach/POR behavior.\n  - The system must tolerate that sram_re_o is asserted continuously; design memory wrapper accordingly if needed.",
        "Supported Modes and Speeds": "Supported Modes and Speeds\n- USB device role only (no host/OTG)\n- Link speeds\n  - High-Speed (HS, 480 Mbps) over 8-bit UTMI; typical phy_clk ≈ 60 MHz\n  - Full-Speed (FS, 12 Mbps) over 8-bit UTMI; typical phy_clk ≈ 12 MHz\n  - Low-Speed (LS) not supported\n- Speed negotiation and fallback\n  - HS negotiation via FS chirp; enters HS on detecting six alternating K/J chirps\n  - Automatic fallback to FS if HS negotiation fails\n- Operating/link modes\n  - Normal operation in HS and FS with UTMI Normal OpMode (OpMode=00)\n  - Reset handling with UTMI bit-stuff/NRZI disabled during signaling (OpMode=10)\n  - Suspend (low-power) and Resume (host- or device-initiated remote wake)\n  - Attach debounce and bus reset detection (SE0 window)\n- Endpoint and transfer modes\n  - EP0 always present; EP1..EP15 build-time enable (this build: EP0–EP3)\n  - Supported transfer types (per-EP CSR): Control, Bulk, Interrupt, Isochronous\n  - HS-specific features: PING acceptance and NYET responses for OUT flow control\n  - Zero-length packet support; data PID sequencing (DATA0/1/2/MDATA)\n- Timing/reference\n  - SOF reception and microframe timing (frm_nat) in HS mode\n  - Internal timing based on build-time constants (e.g., ~250 ns ticks) for ACK wait, reset, resume, HS chirps\n- Not supported/limitations (mode-related)\n  - USB 2.0 HS Test Modes (Test_J/K/SE0_NAK/Test_Packet) not implemented\n  - Certain Chapter 9 control-pipe guarantees (e.g., unconditional SETUP accept) rely on firmware",
        "Use Cases and System Context": "Use Cases and System Context\n- System context (typical SoC integration)\n  - CPU/SoC bus (Wishbone) configures the USB device core via a small register file (RF) and accesses the shared packet SRAM through a memory window (MA)\n  - An external UTMI/UTMI+ PHY provides the HS/FS electrical layer; the RTL implements link/protocol\n  - A single-port synchronous 32-bit SRAM (or a wrapper to on-chip SRAM) holds endpoint packet buffers; the USB datapath arbitrates with software accesses (USB side has priority)\n  - Interrupts (inta_o/intb_o) notify the CPU; optional system DMA can handshake per-endpoint via dma_req_o/dma_ack_i\n  - Two clock domains: phy_clk for USB/protocol/memory, clk_i for Wishbone/CPU view\n\n- Typical topologies\n  - Embedded ASIC/FPGA SoC with: CPU (Wishbone master) + usbf_top (Wishbone slave) + external UTMI PHY + on-chip/off-chip SRAM\n  - FPGA board with discrete UTMI PHY and a small SRAM or BRAM-based wrapper, CPU core (e.g., softcore) running USB device firmware\n  - SoC with centralized DMA engine using per-EP dma_req/ack to move payloads while CPU handles control/descriptor logic\n\n- Representative use cases\n  - General-purpose USB 2.0 device endpoints (control/bulk/interrupt/isochronous) at FS/HS:\n    - Mass-storage–like bulk endpoints (vendor or MSC-style firmware)\n    - CDC/ACM serial bridge or vendor-specific bulk pipes for logging/firmware update\n    - HID/interrupt-style status and control channels\n    - Isochronous streaming (audio/measurement) where firmware manages timing/pacing\n  - Bootloader/DFU-style in-system firmware updates using EP0 and a bulk/interrupt pipe\n  - High-throughput data ingest/egress to on-chip memory via DMA, with software servicing descriptors and interrupts\n  - Low-power peripherals leveraging suspend/resume and device-initiated remote wake\n\n- Data flow and responsibilities at runtime\n  - Host drives tokens; protocol engine validates PIDs/CRCs, matches address/endpoint, and executes IN/OUT/SETUP\n  - Payloads move through an internal byte↔word DMA bridge to/from the shared SRAM; software or system DMA manages buffer descriptors (BUF0/BUF1)\n  - Software configures function address, per-EP CSR (type/direction/MPS/policy), installs buffer descriptors, and services interrupts; optional: issues remote-wakeup\n  - RF exposes live link state (suspend/HS/attached/LineState) and UTMI vendor sideband for PHY-specific needs\n\n- Integration patterns\n  - Software-driven (no external DMA): set csr.dma_en=0 and move data via Wishbone to the MA window; suitable for moderate throughput or FS-only designs\n  - DMA-assisted: enable csr.dma_en and connect dma_req_o/dma_ack_i to a system DMA for sustained HS bulk/iso traffic; CPU handles descriptors and events\n  - Memory choice: attach a discrete synchronous SSRAM or wrap on-chip SRAM/BRAM to present a 32-bit, single-port synchronous interface; ensure timing fits fixed-priority arbiter\n\n- Constraints and when not to use\n  - Device role only (no host/OTG)\n  - Requires an external UTMI/UTMI+ PHY; LS mode not supported\n  - External single-port synchronous 32-bit SRAM (or equivalent wrapper) required for packet buffers\n  - Under heavy USB traffic, Wishbone access to the SRAM window may be delayed (USB master has priority)\n  - For certification-grade USB 2.0 HS test modes and certain EP0 Chapter 9 guarantees, additional RTL/firmware measures are needed\n\n- Example deployment scenarios\n  - FPGA-based instrument appearing as a composite USB device (CDC + vendor bulk) at HS, streaming sensor data into on-chip memory via DMA\n  - Embedded gateway providing a vendor bulk pipe for configuration and log retrieval, with remote wake capability\n  - Audio/measurement endpoint using isochronous transfers at HS, with firmware pacing and buffer rotation via double buffers\n  - Field-upgrade bootloader using EP0 control plus a bulk/interrupt pipe to transfer images stored in the shared SRAM",
        "Limitations and Out-of-Scope": "Limitations and Out-of-Scope\n- USB roles and speeds\n  - Device-only core; no host, hub, or OTG functionality\n  - Low-Speed (1.5 Mbps) not supported (FS/HS only via UTMI)\n  - High-Speed Test Modes (Test_J/K/SE0_NAK/Test_Packet) not implemented\n- Chapter 9/control-pipe behavior (firmware-dependent)\n  - Hardware does not guarantee unconditional SETUP acceptance/override-halt\n  - No enforced 8-byte SETUP length check\n  - Overlength control OUT treated as NAK (spec may require STALL)\n  - No guaranteed DATA0 re-init or auto-clear of halt on next SETUP\n  - Status-stage ZLP generation and STALL recovery rely on firmware\n  - Device address reset-to-zero on bus reset not explicitly enforced in hardware\n- Isochronous/interrupt specifics\n  - bInterval enforcement and high-bandwidth (multiple packets per microframe) scheduling not enforced in RTL\n  - ISO IN may NAK when polled without data (no automatic ZLP)\n- PHY and electrical layer\n  - Requires external UTMI/UTMI+ PHY; electrical/timing compliance is out-of-scope for this RTL\n  - Vendor UTMI sideband (VControl/VStatus) is optional/PHY-specific\n- Memory and throughput\n  - Single-port, 32-bit synchronous SRAM only; sram_re_o held high; no byte-enable support (full-word writes)\n  - Fixed-priority arbiter favors USB core; Wishbone accesses to SRAM can be starved under load\n  - External memory latency management is out-of-scope; a wrapper may be required for non-ideal SRAMs\n  - Buffer memory size fixed by build-time SSRAM_HADR\n- Wishbone interface constraints\n  - Wishbone B.3 classic only: no bursts, no pipelining/STALL, no SEL, no ERR/RTY/tags; single-beat cycles\n  - One outstanding transaction at a time; read data must be valid at ACK\n  - CDC caveat: wb_clk != phy_clk usage increases CDC risk beyond provided simple synchronizer\n- DMA and software responsibilities\n  - Per-endpoint dma_req_o requires system DMA or firmware shim; without DMA, HS throughput may be limited\n  - Firmware must manage descriptors, endpoint CSRs, buffer rotation, interrupts, enumeration, and class/vendor requests\n- Endpoint configuration\n  - Endpoint instances are compile-time selectable and must be contiguous; this build enables only EP0–EP3\n- Out-of-scope features\n  - USB descriptor generation, class drivers, composite device policy, and certification artifacts\n  - Split-transaction TT/hub behavior (device ignores SPLIT in practice)\n  - Security, encryption, or data integrity policies beyond USB CRCs\n  - Power management beyond suspend/resume and remote-wakeup signaling"
    },
    "Architecture": {
        "Top-Level Block Diagram and Composition": "Top-Level Block Diagram and Composition\n- External interfaces\n  - UTMI PHY: 8-bit DataIn/Out, TxValid/Ready, RxValid/Active/Error, XcvSelect, TermSel, SuspendM, OpMode[1:0], LineState[1:0], usb_vbus; optional vendor VControl[3:0]/Load, VStatus[7:0]\n  - Wishbone slave: wb_addr_i, wb_data_i/o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o (classic single-beat)\n  - SRAM: sram_adr_o[SSRAM_HADR:0], sram_data_i/o[31:0], sram_we_o, sram_re_o(=1)\n  - Interrupts: inta_o, intb_o; DMA: dma_req_o[15:0], dma_ack_i[15:0]\n  - Power/link: susp_o, resume_req_i\n\n- Clock and reset domains\n  - phy_clk domain: UTMI interface, protocol layer, IDMA, mem_arb, RF core view\n  - clk_i (wb_clk) domain: Wishbone front-end, RF bus view, wb_ack generation\n  - rst_i drives core resets and phy_rst_pad_o (sync by default; optional async via define)\n\n- Structural composition (major blocks)\n  1) usbf_utmi_if\n     - Bridges to UTMI PHY; registers RX signals; handshakes TX (TxValid/TxReady)\n     - Drives UTMI control pins; exposes link status (mode_hs, usb_reset, usb_suspend, usb_attached) and suspend_clr; executes resume K signaling on request\n  2) usbf_pl (protocol layer)\n     - Sub-blocks: usbf_pd (packet decoder, RX), usbf_pe (protocol engine), usbf_pa (packet assembler, TX), usbf_idma (byte↔word DMA)\n     - Enforces USB 2.0 token/data/handshake rules, PID sequencing, timeouts; moves payloads to/from SRAM via simple req/ack bus\n  3) usbf_mem_arb (single-port SRAM arbiter)\n     - Fixed priority: M (protocol/IDMA) over W (Wishbone)\n     - Muxes address/data/we to SRAM; broadcasts read data to both masters\n  4) usbf_rf (register file, interrupt/DMA aggregator)\n     - Bus view (clk_i): global regs (main_csr, address, masks, RF sticky sources, frm_nat, UTMI vendor); per-EP CSR/INT/BUF0/BUF1 windows\n     - Core view (phy_clk): exports live matched-EP CSR/buffers and convenience flags to protocol layer; aggregates interrupts (inta_o/intb_o) and per-EP DMA reqs\n  5) usbf_wb (Wishbone front-end)\n     - Decodes RF vs Memory regions; sequences single transactions; generates one-cycle ACK in wb_clk; simple CDC return path\n\n- Data/control flow (logical diagram)\n  - RX path: UTMI → usbf_utmi_if → usbf_pl.usbf_pd → usbf_pl.usbf_idma → usbf_mem_arb → SRAM\n  - TX path: SRAM → usbf_mem_arb → usbf_pl.usbf_idma → usbf_pl.usbf_pa → usbf_utmi_if → UTMI\n  - Control/status path: CPU (Wishbone) → usbf_wb → (usbf_rf regs | usbf_mem_arb memory window)\n  - Endpoint live view: usbf_rf (core view, phy_clk) → usbf_pl (CSR/BUF0/BUF1 for matched EP, dma_in_buf_sz1/dma_out_buf_avail)\n  - Interrupts: usbf_pl/usbf_ep blocks → usbf_rf per-EP INT → aggregated to inta_o/intb_o (maskable)\n  - DMA sideband: per-EP dma_req_o from RF to system DMA; dma_ack_i returns to RF/EP logic\n\n- Arbitration and handshakes\n  - usbf_mem_arb: grants SRAM to protocol side whenever active; Wishbone served only when M idle (wack paced every other phy_clk)\n  - usbf_wb: single outstanding WB transaction; RF reads/writes ACK immediately; memory ACK on mem_arb grant/ack\n\n- Register map (high level)\n  - Global RF: main_csr (suspend, HS, attached, line_state + resume pulse), function address, INT masks, RF sticky INT sources (read-to-clear), frm_nat, UTMI vendor R/W\n  - Per-EP windows: CSR, INT (read-to-clear), BUF0, BUF1; EP0 always present; EP1..EP15 build-time selectable (this build EP0–EP3)\n\n- Top-level glue\n  - susp_o registered from usb_suspend; resume_req_i latched and cleared by suspend_clr into utmi_if for remote wake\n  - LineState/VStatus captured in phy_clk and exposed via RF/vendor registers",
        "Data Path Overview": "Data Path Overview\n- Clock and domains\n  - phy_clk domain carries the USB byte streams, protocol, internal DMA, SRAM arbitration, and the RF \"core view\"\n  - clk_i (Wishbone) domain carries software control/data via RF \"bus view\" and memory-window transactions; wb_ack is synchronized back to clk_i\n\n- External boundaries\n  - UTMI 8-bit PHY provides RxValid/Active/Error and DataIn to the core and accepts DataOut/TxValid; link control pins (XcvSelect, TermSel, OpMode, SuspendM) are driven per link state\n  - 32-bit synchronous single-port SRAM stores endpoint payload buffers; sram_re_o is tied high; arbiter multiplexes access\n  - Wishbone slave exposes two regions: RF (register file) and MA (packet SRAM window)\n\n- Receive (OUT/SETUP) data path (UTMI → SRAM)\n  1) UTMI byte stream enters usbf_utmi_if and is registered (rx_data, rx_valid, rx_active, rx_err)\n  2) usbf_pl.usbf_pd decodes PID, extracts token fields (function address, endpoint), validates CRC5, then streams DATA bytes and checks CRC16 residue\n  3) usbf_pl.usbf_pe enforces endpoint policy (direction, MPS, small/large OK), selects buffer (BUF0/BUF1), and starts RX DMA when allowed\n  4) usbf_pl.usbf_idma packs bytes into 32-bit words; performs read-modify-write for unaligned starts and flushes the last partial word\n  5) usbf_mem_arb grants the SRAM M-port to the protocol side with hard priority; write data and addresses are driven to SRAM\n  6) On packet end, PE chooses handshake (ACK/NACK/STALL/NYET in HS), updates descriptors (address/size or received count), sets per-EP INT bits, and may flag out_to_small\n\n- Transmit (IN) data path (SRAM → UTMI)\n  1) On an addressed IN token, usbf_pl.usbf_pe checks buffer readiness (dma_in_buf_sz1), selects DATA PID, and starts TX DMA (or requests a zero-length packet)\n  2) usbf_pl.usbf_idma prefetches words from SRAM using a 2-word ping-pong buffer and presents aligned bytes on tx_data_st; rd_next advances per accepted byte\n  3) usbf_pl.usbf_pa assembles the DATA packet: PID → payload → CRC16 (computed by usbf_crc16, reflected/inverted, low byte first); tx_first preloads SOP; tx_valid/tx_valid_last mark transfer boundaries\n  4) usbf_utmi_if handshakes with the PHY (TxValid/TxReady), ensuring last-byte visibility; PE waits for host ACK with HS/FS timeouts and then updates descriptors/INTs\n\n- Control and status path (CPU ⇄ core)\n  - Wishbone → usbf_wb decodes RF vs MA:\n    • RF region: global status/control (main_csr, function address, interrupt masks/sources, frm_nat, UTMI vendor R/W)\n    • Per-EP windows: CSR, INT (read-to-clear), BUF0, BUF1\n  - RF exposes two views:\n    • Bus view (clk_i) for software R/W\n    • Core view (phy_clk) feeding usbf_pl with the matched EP’s live CSR/BUF0/BUF1 and convenience flags (dma_in_buf_sz1, dma_out_buf_avail)\n  - Descriptor write-backs from PE (idin + buf*_set/uc_*_set/buf0_rl) update EP state; RF aggregates per-EP and RF-level events to inta_o/intb_o\n\n- Arbitration and handshakes\n  - usbf_mem_arb prioritizes the protocol (M) master; Wishbone (W) memory accesses are granted only when M is idle (wack paced every other phy_clk)\n  - usbf_wb sequences one transaction at a time; RF ops ACK immediately; MA ops ACK on mem_arb grant\n\n- Protocol guardrails and timing\n  - PID complement, CRC5/CRC16 checks, and token/endpoint matching gate protocol actions\n  - Timeouts (HS/FS) protect IN-ACK wait and OUT activity; frm_nat captures SOF/microframe timing\n  - Link FSM (in utmi_if/utmi_ls) manages attach, reset, suspend/resume, and HS negotiation; outputs mode_hs/usb_reset/usb_suspend/usb_attached\n\n- Typical transaction summaries\n  - OUT/SETUP: Token match → policy check → RX DMA to SRAM → handshake decision → descriptor/INT update\n  - IN: Token match → buffer readiness → TX DMA from SRAM → packet emit and ACK wait → descriptor/INT update\n\n- DMA sidebands and software roles\n  - RF exports per-EP dma_req_o for optional system DMA; dma_ack_i returns; internal IDMA always moves payloads between UTMI and SRAM\n  - Firmware programs EP CSRs and buffer descriptors, services interrupts, and may request remote wake via main_csr",
        "Control and Status Path": "Control and Status Path\n- Bus interface and addressing\n  - Wishbone classic slave (clk_i): wb_addr_i, wb_data_i/o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o\n  - Region select (with USBF_TEST_IMPL): wb_addr_i[17] = 0 → RF (register file), 1 → MA (packet SRAM window)\n  - RF word addressing uses adr[8:2] (32-bit aligned)\n  - ACK generation: RF ops ACK immediately (W0 path); MA ops ACK on mem_arb grant (ma_ack). A 3-FF edge detector returns a clean one-cycle wb_ack_o in wb_clk\n  - One outstanding WB transaction at a time; no bursts/STALL/SEL\n\n- Global control/status (RF, bus view @ clk_i)\n  - 0x00 MAIN_CSR (R), CTRL (W one-shot):\n    • Read bits: [0] suspend, [1] mode_hs, [2] usb_attached, [4:3] line_state\n    • Write bit[5]=1: rf_resume_req pulse (device-initiated resume)\n  - 0x01 FUNC_ADDR (R/W, 7-bit device address)\n  - 0x02 INT_MASKS A/B (R/W): {intb_msk[8:0], inta_msk[8:0]}\n  - 0x03 INT_SOURCES (R, read-to-clear sticky RF events): {usb_reset, rx_err, detach, attach, suspend_end, suspend_start, nse_err, pid_cs_err, crc5_err}\n  - 0x04 FRM_NAT (R): 32-bit SOF/microframe timing snapshot\n  - 0x05 UTMI_VENDOR (R/W): read VStatus[7:0]; write VControl[3:0] with VControl_Load pulse\n\n- Per-endpoint control/status (RF, bus view @ clk_i)\n  - EPn window base = 0x10 + 4*n; offsets: +0 CSR (R/W), +1 INT (R/W, read-to-clear in EP), +2 BUF0 (R/W), +3 BUF1 (R/W)\n  - CSR (conceptual fields): direction (IN/OUT/CTRL), endpoint number, DMA enable, max packet size, policy bits (sml_ok/lrg_ok), STALL, software buffer select (uc_bsel) and data-PID base/toggle (uc_dpd)\n  - INT: sticky per-EP causes (buf0_set, buf1_set, buf0_rl, int_crc16_set, int_to_set, int_upid_set, int_seqerr_set, out_to_small); cleared on read or write\n  - BUF0/BUF1: buffer descriptors (address/size, write-backs from core)\n\n- Interrupt model and aggregation\n  - Per-EP enables: iena/ienb in the EP block drive inta/intb per endpoint\n  - RF-level sticky events (INT_SOURCES) masked by INT_MASKS A/B and OR’ed with per-EP trees to produce inta_o/intb_o\n  - Software reads 0x03 to clear RF-level sticky sources; per-EP INT clears on EP INT read/write\n\n- Core view and CDC bridges (clk = phy_clk)\n  - RF core view exports the matched endpoint’s live CSR/BUF0/BUF1 and convenience flags (dma_in_buf_sz1, dma_out_buf_avail) to the protocol layer\n  - match indicates any EP matched ep_sel this cycle; priority-encoded view feeds usbf_pl\n  - rf_resume_req (from MAIN_CSR write) and utmi_vend_wr are generated as one-shots across clock domains\n  - wb ACK path uses edge-detected CDC back to wb_clk; LineState_r and VStatus_r latched in phy_clk for RF readback\n\n- Link and power state control\n  - usbf_utmi_if/usbf_utmi_ls manage attach, reset, suspend/resume, HS negotiation; export mode_hs, usb_reset, usb_suspend, usb_attached, suspend_clr\n  - susp_o is a clk_i-domain registered copy of usb_suspend\n  - resume_req_i is latched as resume_req_r, auto-cleared by suspend_clr, and drives UTMI resume signaling via utmi_if\n\n- DMA sidebands and ownership\n  - RF aggregates per-EP dma_req_o[15:0] to the system; dma_ack_i[15:0] returns\n  - Inside EP RF, request/ack uses robust two-domain handshakes with hold logic to sustain bursts; counters expose readiness (dma_in_buf_sz1) and available space (dma_out_buf_avail)\n  - Descriptor/state updates from the protocol engine use idin plus strobes (buf0_set, buf1_set, uc_bsel_set, uc_dpd_set, buf0_rl) in phy_clk; RF applies them to the matched EP\n\n- Memory-array (MA) window control\n  - Wishbone MA accesses (wb_addr_i[17]=1) route through usbf_wb to usbf_mem_arb; arbiter grants only when the protocol (M) master is idle\n  - usbf_mem_arb broadcasts read data to both masters; wack for W pulses every other phy_clk during service\n\n- Software responsibilities (typical flow)\n  - Configure FUNC_ADDR, per-EP CSR (direction/type/MPS/DMA), and BUF0/BUF1\n  - Enable interrupts (RF-level masks and per-EP iena/ienb); service inta_o/intb_o by reading per-EP INT and RF INT_SOURCES\n  - For vendor PHY features: use UTMI_VENDOR R/W at 0x05\n  - Optional remote-wake: write MAIN_CSR bit[5]\n  - For packet SRAM access without DMA: use MA window; with DMA: connect dma_req_o/ack_i and manage descriptors\n\n- Visibility and diagnostics\n  - main_csr reports suspend/HS/attach/line_state; frm_nat provides SOF timing; RF sticky sources capture link/protocol anomalies (pid_cs_err, crc5_err, nse_err, usb_reset, etc.)\n  - Per-EP INT exposes buffer events and protocol outcomes; BUF descriptors show write-backs (size/count/address advances)",
        "Clock and Reset Domains": "Clock and Reset Domains\n- Domains overview\n  - phy_clk (phy_clk_pad_i): Drives UTMI interface (RX/TX and line control), protocol layer (usbf_pl: pd/pe/pa/idma), memory arbiter (usbf_mem_arb), and the RF core view (matched-EP CSR/BUFs, DMA status)\n  - clk_i (wb_clk): Drives Wishbone front-end (usbf_wb), RF bus view (global regs and per-EP windows), and top-level status outputs such as susp_o\n\n- Reset distribution and style\n  - rst_i is the top-level reset source; it fans into both domains and also drives phy_rst_pad_o toward the PHY\n  - Default reset style is synchronous in all modules; optional USBF_ASYNC_RESET enables asynchronous reset on selected flops (e.g., UTMI RX/TX path registers)\n  - On reset: RF globals clear to 0 (FUNC_ADDR=0, masks=0); EP CSRs/BUFs reset in each endpoint RF instance; utmi_if state machine enters POR; susp_o reflects the reset state after re-synchronization\n\n- Domain placement by block\n  - UTMI/Link: usbf_utmi_if and its submodule usbf_utmi_ls fully in phy_clk; generate mode_hs, usb_reset, usb_suspend, usb_attached, suspend_clr, and drive XcvSelect/TermSel/OpMode/SuspendM\n  - Protocol/Data path: usbf_pl (pd/pe/pa/idma) in phy_clk; all token/CRC/transaction engines and SRAM req/ack occur here\n  - Memory arbiter: usbf_mem_arb in phy_clk (wclk input is unused); fixed-priority M-over-W arbitration and wack pacing occur in phy_clk\n  - Register file: usbf_rf has two views—core view in phy_clk (matched-EP CSR/BUF0/BUF1, dma_in_buf_sz1, dma_out_buf_avail) and bus view in clk_i (global regs, per-EP windows, interrupt aggregation)\n  - Wishbone front-end: usbf_wb straddles domains—its FSM and target handshakes in phy_clk; the ACK pulse and wb_data_o are registered in wb_clk (clk_i)\n\n- Cross-domain crossings and synchronization\n  - Wishbone ACK back to wb_clk: usbf_wb uses a 3-FF edge-detector pipeline to generate a single-cycle wb_ack_o in clk_i\n  - Wishbone request sampling: wb_req_s1 is sampled directly into phy_clk from (wb_stb_i & wb_cyc_i); best used when wb_clk == phy_clk or otherwise phase-related/closed for CDC\n  - RF bus↔core view: per-EP descriptor/control updates cross from phy_clk (idin + buf0_set/buf1_set/uc_bsel_set/uc_dpd_set/buf0_rl) into the RF bus domain using ep_match gating and internal CDC in usbf_rf; matched-EP live CSR/BUFs are exposed from phy_clk to the protocol layer\n  - DMA sideband per endpoint: dma_req (wclk) ⇄ dma_ack (clk) use a robust two-domain handshake and \"hold\" logic inside usbf_ep_rf to sustain bursts without metastability\n  - Remote wake: MAIN_CSR write in clk_i generates rf_resume_req as a one-shot into phy_clk; utmi_if consumes it and issues resume; suspend_clr from phy_clk clears the latched request\n  - UTMI vendor sideband: writes at 0x05 in clk_i generate utmi_vend_wr and VControl[3:0] one-shots into phy_clk; VStatus[7:0] is latched in phy_clk then read in clk_i\n  - Link state reporting: usb_suspend (phy_clk) is re-timed and reported as susp_o in clk_i; LineState_r and VStatus_r are captured in phy_clk for RF readback in clk_i\n\n- Clocking constraints and recommendations\n  - For safest operation, keep wb_clk (clk_i) equal to phy_clk or otherwise frequency/phase-aligned; if not, note the CDC risk on Wishbone request sampling into phy_clk\n  - usbf_mem_arb’s wclk is unused; both initiators at this boundary must adhere to phy_clk timing or be synchronized externally\n\n- Reset sequencing notes\n  - utmi_if state machine asserts usb_reset in RESET and provides suspend_clr upon exiting suspend; these events fan into RF (sticky sources) and top-level status\n  - All PID/CRC engines and protocol counters reset synchronously to phy_clk; Wishbone-visible registers reset synchronously to clk_i unless USBF_ASYNC_RESET is enabled in specific blocks\n\n- Summary\n  - Two primary synchronous domains (phy_clk and clk_i) with well-defined CDC bridges for ACK, DMA handshakes, per-EP updates, vendor control, and remote-wakeup; synchronous resets by default, optional async for selected UTMI path flops; recommend clk_i == phy_clk for simplest CDC posture",
        "Clock-Domain Crossing Strategy": "Clock-Domain Crossing Strategy\n- Partitioning to minimize CDC\n  - Data/control engines that must meet USB timing (UTMI RX/TX, protocol layer, IDMA, SRAM arbiter, link FSM) run entirely in phy_clk\n  - Software-visible control/status and bus transactions (Wishbone front-end, RF bus view, top-level status) run in clk_i (wb_clk)\n\n- Primary crossings and techniques\n  1) Wishbone request/ack (wb_clk ⇄ phy_clk)\n     - Requests: wb_req_s1 is sampled directly in phy_clk from (wb_stb_i & wb_cyc_i); safe when wb_clk == phy_clk or phase-related; otherwise CDC risk noted\n     - ACK return: a 3-FF edge-detector pipeline in wb_clk generates a clean, single-cycle wb_ack_o from phy-domain wb_ack_d (rising-edge capture, one-shot)\n  2) RF bus view ⇄ core view (clk_i ⇄ phy_clk)\n     - Descriptor write-backs from protocol side (idin + buf0_set/buf1_set/uc_*_set/buf0_rl) originate in phy_clk and are applied in RF to the matched endpoint with internal CDC gating; ep_match ensures only the selected EP captures updates\n     - Live matched-EP CSR/BUF and convenience flags (dma_in_buf_sz1, dma_out_buf_avail) are produced in phy_clk and exposed to the protocol engine without crossing back to wb_clk\n  3) Per-endpoint DMA handshake (clk_i ⇄ phy_clk)\n     - Requests: dma_req_d (phy_clk) is converted to a wclk-domain one-shot (dma_req_r) with hold logic to sustain bursts\n     - Acks: wclk toggles a handshake bit (dma_ack_wr1) on dma_ack; phy_clk samples via a 2‑FF chain (r4/r5) to produce a clean ack pulse (dma_ack_i). wclk clears the toggle when seen (r4)\n  4) Remote wake (wb → PHY)\n     - MAIN_CSR write in clk_i generates rf_resume_req as a one-shot into phy_clk; utmi_if consumes it to issue resume K; suspend_clr (phy_clk) returns to clear the latched request\n  5) UTMI vendor sideband (wb ⇄ PHY)\n     - Writes at 0x05 in clk_i produce VControl[3:0] with a one-shot utmi_vend_wr into phy_clk; VStatus[7:0] is latched in phy_clk and read in clk_i\n  6) Link state/status (PHY → wb)\n     - usb_suspend/mode_hs/usb_attached/LineState are generated in phy_clk; susp_o is re-timed/registered in clk_i; LineState_r and VStatus_r are captured in phy_clk and made readable via RF in clk_i\n\n- Arbiter/bus boundary\n  - usbf_mem_arb operates solely in phy_clk; wclk input is unused. Wishbone MA transactions are sequenced by usbf_wb in phy_clk and acknowledged back to wb_clk via the ACK edge synchronizer\n\n- Reset interaction with CDC\n  - Resets are synchronous by default in both domains (optional USBF_ASYNC_RESET for selected UTMI path flops), reducing reset-related CDC hazards\n  - utmi_if link FSM asserts usb_reset/suspend_clr in phy_clk; RF captures these as sticky/read-to-clear events in clk_i\n\n- Metastability mitigation summary\n  - One-shot pulse crossings for control strobes (rf_resume_req, utmi_vend_wr)\n  - 2‑FF/3‑FF synchronizers with edge detection for return handshakes (Wishbone ACK, DMA ack)\n  - Level-sensitive request sampling called out as a CDC caveat (wb_req_s1 into phy_clk); recommended same/locked clocks\n  - Gated update buses (ep_match) to limit fan-in and ensure single-EP capture on RF updates across domains\n\n- CDC caveats and recommendations\n  - Best practice: keep clk_i == phy_clk (same frequency/phase) or close timing on the wb_req sampling path; otherwise insert conventional 2‑FF synchronizers for wb_req\n  - Ensure system DMA honoring dma_req_o/dma_ack_i observes the described toggle/hold semantics across domains\n  - External wrappers may be required if additional CDC is introduced at the SRAM or Wishbone boundary in the host system",
        "Memory/Buffer Architecture and Arbitration": "Memory/Buffer Architecture and Arbitration\n- Physical memory and porting\n  - External synchronous single-port SRAM (SSRAM) with 32-bit data bus; address width set by SSRAM_HADR\n  - sram_re_o tied high; reads always enabled. Read data is broadcast to both masters (core and Wishbone)\n  - Effective buffer space size (bytes) = 4 × 2^(SSRAM_HADR+1). With test build (SSRAM_HADR=14) this is 128 KiB\n\n- Addressing model and alignment\n  - Core-side (phy_clk) uses word-address madr[SSRAM_HADR:0] and 32-bit mdin/mdout with mreq/mwe/mack handshake\n  - IDMA operates on byte addresses adr[SSRAM_HADR+2:0] split into: adr_cw = adr[SSRAM_HADR+2:2] (word index) and adr_cb = adr[2:0] (byte offset within first word)\n  - RX path does an initial read-modify-write for unaligned starts and flushes a partial last word; TX uses 2-word ping-pong prefetch and byte muxing by adrb_next[2:0]\n  - Optional ring/wrap addressing when dma_en is set: address wraps to 0 at last_buf_adr = adr + buf_size\n\n- Endpoint buffer model\n  - Each endpoint exposes two 32-bit buffer descriptors: BUF0 and BUF1\n    • Address field: bufX_adr = bufX[SSRAM_HADR+2:0]; a sentinel (bufX[31] or all-ones) indicates not-available\n    • Size field: bufX_sz = bufX[30:17]\n  - Buffer selection policy:\n    • If dma_en: DMA path is fixed to BUF0\n    • If CTRL: direction-based (IN→BUF1, OUT/SETUP→BUF0)\n    • Otherwise: prefer uc_bsel (SW-select); auto-fallback to the other buffer if current is NA\n  - Software writes descriptors via RF bus view; hardware writes back updates via idin on events\n\n- Descriptor updates and write-back (performed by protocol engine)\n  - After a transfer, idin carries new size/address and control bits; buf0_set/buf1_set strobes commit descriptor updates\n  - IN: new_size = buf_size − size_next; new_adr = adr + size_next; buffer_done when new_size == 0\n  - OUT with DMA: new_size based on MPS and advances by MPS; OUT without DMA uses received count (sizu_c)\n  - HS OUT short (out_to_small): preserves original address, writes received count, sets a status flag\n  - uc_bsel_set/uc_dpd_set strobes update SW-visible buffer select and data-PID base; buf0_rl releases DMA buffer ownership when done (DMA mode)\n\n- Data movers (IDMA)\n  - RX (USB→SRAM): packs bytes into 32-bit words; RMW at start if unaligned; emits word writes on boundaries and a final flush\n  - TX (SRAM→USB): two-word ping-pong prefetch; aligned byte mux to tx_data_st; rd_next pacing; send_zero_length supported without fetch\n  - Handshake to memory: mreq (held until ack for reads; pulsed on writes), mwe for write cycles, mack registered as mack_r\n\n- Arbitration (usbf_mem_arb)\n  - Two masters to one SRAM port in phy_clk domain:\n    • M (core/protocol/IDMA) has strict priority and receives immediate mack = mreq\n    • W (Wishbone/system) is granted only when M is idle; wack pulses every other phy_clk during service\n  - sram_adr/sram_dout/sram_we are muxed by selection; read data feeds both masters concurrently\n\n- Software access to memory/buffers\n  - Wishbone Memory Array (MA) window selected by wb_addr_i[17]=1; single-beat reads/writes sequenced by usbf_wb FSM in phy_clk\n  - ACK returned to wb_clk via a 3-FF edge-detected one-shot; data returned from ma_din when granted\n  - Register File (RF) window (wb_addr_i[17]=0): global status/control and per-EP CSR/INT/BUF0/BUF1\n\n- DMA request/ack and flow control (per endpoint)\n  - RF aggregates per-EP dma_req_o[15:0] outward; accepts dma_ack_i[15:0] inward\n  - Internal counters implement availability/readiness:\n    • IN: prefill until capacity; exports dma_in_buf_sz1 when ≥ one MPS is buffered\n    • OUT: tracks remaining capacity from buf0_orig; exports dma_out_buf_avail when ≥ one MPS fits\n  - Robust two-domain handshake with hold logic sustains bursts and avoids metastability\n\n- Throughput and timing safeguards\n  - Core gets unconditional priority at the SRAM to meet packet timing; Wishbone accesses are best-effort\n  - TX prefetch and RX RMW/flush ensure continuous streaming and data integrity across alignment boundaries\n\n- Build-time/configuration knobs\n  - SSRAM_HADR defines memory depth/size; USBF_UFC_HADR selects internal address width; endpoints enabled via USBF_HAVE_EPx\n\n- Practical notes\n  - BUF descriptors reset to invalid; software must program CSR and BUF0/BUF1 before enabling endpoints\n  - Read data is always visible at both masters; each must only sample on its respective ack\n  - A 0xFFFF_FFFF buffer value denotes NA and is used by selection logic to avoid unavailable buffers",
        "Address Map Partitioning": "Address Map Partitioning\n- Top-level Wishbone region split\n  - Address bit wb_addr_i[17] selects region (USBF_TEST_IMPL build):\n    • 0: RF (Register File; control/status, per-endpoint CSRs and descriptors)\n    • 1: MA (Memory Array; external packet SRAM window)\n  - Bus is 32-bit word-aligned; within RF, addresses use word indices N mapped to byte address 4×N\n\n- RF (Register File) region layout (wb_addr_i[17]=0)\n  - Global block (word addresses)\n    • 0x00 MAIN_CSR / CTRL\n      - Read: {suspend[0], mode_hs[1], usb_attached[2], line_state[4:3]}\n      - Write: bit[5]=1 generates remote-wakeup (rf_resume_req) one-shot\n    • 0x01 FUNC_ADDR (R/W, 7-bit device address)\n    • 0x02 INT_MASKS A/B (R/W): {intb_msk[8:0], inta_msk[8:0]}\n    • 0x03 INT_SOURCES (R, read-to-clear RF sticky events): {usb_reset, rx_err, detach, attach, suspend_end, suspend_start, nse_err, pid_cs_err, crc5_err}\n    • 0x04 FRM_NAT (R): 32-bit SOF/microframe timing snapshot\n    • 0x05 UTMI_VENDOR (R/W): read VStatus[7:0]; write VControl[3:0] with load strobe\n  - Per-endpoint windows (EPn, n=0..15), base word = 0x10 + 4×n\n    • +0: EPn_CSR (R/W) — direction, endpoint number, DMA enable, MPS, policy, STALL, uc_bsel/uc_dpd\n    • +1: EPn_INT (R/W, read-to-clear) — buffer/Protocol events: buf0_set, buf1_set, buf0_rl, int_crc16_set, int_to_set, int_upid_set, int_seqerr_set, out_to_small\n    • +2: EPn_BUF0 (R/W) — buffer 0 descriptor (address/size, write-backs)\n    • +3: EPn_BUF1 (R/W) — buffer 1 descriptor\n  - Notes\n    • Current build enables EP0..EP3; remaining EP windows are present but may return reset defaults\n    • All RF accesses are 32-bit word-aligned; INT_SOURCES and EPn_INT are read-to-clear\n\n- MA (Memory Array) region layout (wb_addr_i[17]=1)\n  - Maps to external 32-bit SSRAM via usbf_mem_arb; single-beat read/write\n  - Effective SRAM word index = wb_addr_i[SSRAM_HADR+2:2]\n  - Size (bytes) = 4 × 2^(SSRAM_HADR+1); test build SSRAM_HADR=14 → 128 KiB window\n  - ACK is returned when mem arbiter grants/completes; protocol side has priority\n\n- Decode/handshake behavior (usbf_wb)\n  - One outstanding transaction at a time; RF ops ACK immediately; MA ops ACK on arbiter grant\n  - ACK returned to wb_clk as a clean one-cycle pulse\n\n- Build-time knobs affecting map\n  - Region select bit and widths depend on USBF_TEST_IMPL, USBF_UFC_HADR, SSRAM_HADR\n  - Endpoint presence controlled by USBF_HAVE_EPx defines\n\n- Practical summary\n  - Use RF space (wb_addr_i[17]=0) for global control/status and per-EP CSR/INT/BUF0/BUF1 programming\n  - Use MA space (wb_addr_i[17]=1) to read/write the shared packet SRAM (word-aligned)\n  - Key control bits: MAIN_CSR write bit[5] (remote wake request); UTMI_VENDOR lower nibble drives PHY VControl",
        "DMA Architecture": "DMA Architecture\n- Overview\n  - Two-layer DMA scheme:\n    • Core IDMA (inside usbf_pl/usbf_idma, phy_clk) moves payload between UTMI byte stream and 32-bit external SSRAM\n    • Per-endpoint DMA control in usbf_rf generates/consumes endpoint-level DMA service requests (dma_req_o/ack_i) and maintains availability counters; also bridges clk_i ⇄ phy_clk with robust handshakes\n\n- Core IDMA (usbf_idma, phy_clk)\n  - Interfaces to memory via simple handshake: mreq/mack, mwe, madr[SSRAM_HADR:0], mdout/mdin\n  - RX (USB→SRAM):\n    • Accepts rx_data_st/valid/done\n    • Handles unaligned starts with an initial read-modify-write (RMW); assembles 32-bit words in dtmp_r\n    • Issues word writes on boundaries and a forced final write (flush) for partial last word\n  - TX (SRAM→USB):\n    • Two-word ping-pong prefetch buffers; rd_next pacing to source bytes to tx_data_st\n    • Aligned byte mux by adrb_next[2:0]; supports zero-length packets (send_zero_length) without memory fetch\n  - Addressing and wrap:\n    • Operates on byte address adr[SSRAM_HADR+2:0] split into word index adr_cw and byte offset adr_cb\n    • Optional ring/wrap when dma_en set; wraps at last_buf_adr = adr + buf_size\n  - Completion/flow:\n    • idma_done flags RX packet end or TX size exhausted\n    • send_data indicates TX data availability (raised on first read acknowledge)\n\n- Per-endpoint DMA control (usbf_rf/usbf_ep_rf)\n  - Exposes two 32-bit buffer descriptors per EP (BUF0/BUF1) with address (bufX_adr) and size (bufX_sz)\n  - Endpoint policies select active buffer (DMA→BUF0; CTRL IN→BUF1, CTRL OUT/SETUP→BUF0; otherwise uc_bsel with NA fallback)\n  - Counters and thresholds (word units):\n    • IN (device→host): dma_in_cnt increments on memory acks, decrements by MPS (P) at packet set; dma_in_buf_sz1 asserted when ≥1 MPS buffered\n    • OUT (host→device): dma_out_cnt increments by P at packet set, decrements on memory acks; dma_out_buf_avail asserted when remaining capacity ≥1 MPS\n  - Descriptor write-back bus (idin + buf0_set/buf1_set/uc_bsel_set/uc_dpd_set, buf0_rl) updates sizes/addresses, toggles SW-visible selects/PID base, and releases buffers in DMA mode; HS OUT short (out_to_small) preserves original address and records received count\n  - Endpoint DMA request interface:\n    • Aggregated outward: dma_req_o[15:0]; inward acknowledges: dma_ack_i[15:0]\n    • Robust two-domain handshake with hold logic sustains bursts and prevents metastability (one-shot request raise; ack toggle sync back to phy_clk)\n\n- Memory arbitration and QoS (usbf_mem_arb, phy_clk)\n  - Single-port 32-bit SSRAM shared by:\n    • M master = core IDMA/protocol (absolute priority, mack=mreq)\n    • W master = Wishbone software accessor (served only when M idle; wack pulses every other phy_clk)\n  - Read data broadcast to both masters; sram_re tied high\n  - Ensures USB data path timing while pacing software accesses\n\n- Control points and configuration\n  - CSR fields: endpoint direction/type, dma_en, MPS (csr[10:0]), policy bits, uc_bsel/uc_dpd\n  - BUF0/BUF1 descriptors programmed by software; buf0_orig retained as capacity/limit reference for DMA accounting\n  - Ring/wrap enable via dma_en; size and address advances per transfer type (IN uses size_next; OUT DMA advances by MPS; OUT non-DMA uses sizu_c)\n\n- CDC and reliability\n  - DMA req/ack across clk_i ⇄ phy_clk uses toggle/one-shot plus 2-FF/edge-detect synchronizers\n  - Wishbone ACK crosses domains via 3-FF edge detector; recommended clk_i == phy_clk for safest operation\n\n- Throughput aids and edge cases\n  - Two-word TX prefetch and RX RMW/flush preserve streaming and alignment\n  - Timeouts and error flags from usbf_pe (int_to_set, int_crc16_set, int_seqerr_set) coordinate with DMA completion/aborts\n  - Zero-length IN supported without memory fetch\n\n- Build-time parameters\n  - SSRAM_HADR defines memory depth; USBF_UFC_HADR affects bus address width; endpoint presence via USBF_HAVE_EPx\n\n- Software interaction (summary)\n  - Program EP CSR and BUF0/BUF1; enable DMA (csr[15]) where desired\n  - Monitor per-EP INT and RF-level INT_SOURCES; respond to dma_req_o/ack_i if system DMA participates\n  - Use MA window for direct SSRAM access when needed; protocol side retains priority",
        "Interrupt Architecture": "Interrupt Architecture\n- Top-level interrupt lines\n  - Two outputs: inta_o and intb_o (active-high)\n  - Each is the OR of:\n    • Aggregated per-endpoint interrupt lines (inta_ep/intb_ep)\n    • RF-level sticky event interrupts masked into the respective channel (inta_rf/intb_rf)\n\n- RF-level (global) interrupts (usbf_rf, wclk domain)\n  - Sticky event register INT_SOURCES at 0x03 (read-to-clear) captures edges/conditions from the link/protocol side:\n    • usb_reset, rx_err_r, detach, attach, suspend_end, suspend_start, nse_err_r, pid_cs_err_r, crc5_err_r\n  - Masking and routing: INT_MASKS at 0x02 provide two independent 9-bit masks (inta_msk/intb_msk) to route any subset of RF sticky events to inta_o or intb_o\n  - Software behavior: read 0x03 to clear sticky RF events after servicing; masks at 0x02 configure which RF events contribute to A vs B\n\n- Per-endpoint interrupts (usbf_ep_rf)\n  - Each endpoint exposes an INT register (EPn_INT at base+1) that is read-to-clear and holds sticky causes set by protocol-layer strobes:\n    • int_buf0_set, int_buf1_set, buf0_rl, int_crc16_set, int_to_set, int_upid_set, int_seqerr_set, out_to_small\n  - Two per-EP enable masks (written via EPn_INT) gate delivery onto the A vs B channels:\n    • iena[5:0] → per-EP inta\n    • ienb[5:0] → per-EP intb\n  - usbf_rf aggregates per-EP inta across all enabled endpoints into inta_ep; similarly for intb_ep into intb_o path\n  - Event sourcing and gating:\n    • Protocol-side event strobes (phy_clk) are gated by ep_match and latched into EP sticky status\n    • Read of EPn_INT clears that endpoint’s latched causes\n\n- Source domains and CDC\n  - Event generation (protocol/link) originates in phy_clk; RF/EP sticky status and A/B aggregation occur in wclk (clk_i)\n  - Crossings use internal gating/synchronization (ep_match-based capture in clk, exported as wclk-domain INTs); RF-level stickies capture link events and present them in wclk\n\n- Software-visible register map (relevant to interrupts)\n  - 0x02 INT_MASKS: RF-level A/B masks\n  - 0x03 INT_SOURCES: RF-level sticky events (read-to-clear)\n  - EPn window +1: EPn_INT (read-to-clear sticky per-EP causes; also holds enable masks for routing to A/B)\n\n- Typical usage\n  - Configure RF masks (0x02) and per-EP enable masks to route desired events to inta_o and/or intb_o\n  - On inta_o/intb_o assertion:\n    • Read 0x03 to check and clear RF-level sticky events\n    • Probe EPn_INT for active endpoints to identify and clear per-EP causes\n\n- Event taxonomy (examples)\n  - Link/RF-level: attach/detach, suspend start/end, bus reset, PHY RX error, header/PID/CRC5 anomalies, non-selected endpoint token\n  - Endpoint-level: buffer ready/released, CRC16 error, timeout, unexpected PID, sequence error, HS OUT short-packet condition\n\n- Notes\n  - All sticky bits are level-true until explicitly cleared by software (read-to-clear registers)\n  - Two-channel (A/B) routing is provided independently at both RF-level and per-EP level, allowing flexible partitioning of interrupt sources across inta_o and intb_o",
        "Power Management and Link State Control": "Power Management and Link State Control\n- Link-state controller (phy_clk)\n  - Implemented in usbf_utmi_ls (instantiated by usbf_utmi_if); one-hot FSM governs:\n    • POR → ATTACH (100 ms debounce) → NORMAL (FS/HS)\n    • SUSPEND entry on long idle; RESUME via host K or device remote-wake\n    • RESET detection on qualified SE0 window\n    • HS negotiation via FS chirp: device K drive, count host K/J chirps; enter HS on six chirps, else fallback to FS\n  - Derived timing windows with ~250 ns tick basis: thresholds for 100 µs, 0.5 ms, 1.0/1.2 ms, 3.0 ms, 5.0 ms, 30/50/100 ms (per macros)\n  - Line-state qualification: J/K/SE0/SE1 with \"+long\" two-sample qualifiers; idle detection (FS=J, HS=SE0)\n\n- UTMI control during states\n  - XcvSelect: HS vs FS receiver select (0=HS, 1=FS)\n  - TermSel: FS termination enable\n  - OpMode: 00=Normal; 10=Disable bit-stuff/NRZI during reset/resume/chirp\n  - SuspendM: asserted when not suspended (and per line-state conditions) to place PHY in/out of low power\n  - drive_k: asserts K on the bus during resume signaling and HS chirp\n\n- Speed mode and status exports (phy_clk)\n  - mode_hs: latched after HS negotiation success; 0 in FS\n  - usb_attached: set after attach debounce; cleared at POR\n  - usb_suspend: set entering SUSPEND; cleared on resume/reset\n  - usb_reset: asserted during RESET state\n  - suspend_clr: one-shot pulse when leaving/avoiding suspend\n\n- Suspend and resume behavior\n  - Suspend entry: idle_long exceeds threshold (HS observes via FS view) → usb_suspend=1, SuspendM deasserted (PHY low-power)\n  - Host-initiated resume: K detection → resume sequence, return to NORMAL after settle (~100 µs)\n  - Function-initiated remote-wakeup:\n    • Software writes MAIN_CSR bit[5] (rf_resume_req) in clk_i domain\n    • One-shot crosses to phy_clk; usbf_utmi_ls waits ~5 ms (T2_wakeup), then drives K for ~1 ms (RESUME_SIG)\n    • Restores OpMode/XcvSelect/TermSel, asserts suspend_clr, returns to NORMAL after ~100 µs settle\n\n- Bus reset handling\n  - Qualified SE0 → RESET state: usb_reset asserted, OpMode=10, FS termination on, speed negotiation sequence starts after ~1 ms\n\n- Top-level and software-visible integration\n  - susp_o: registered copy of usb_suspend in clk_i domain (system-facing suspend state)\n  - MAIN_CSR (0x00, read): {suspend, mode_hs, usb_attached, line_state[1:0]}; write bit[5] to request remote wake (one-shot)\n  - RF-level sticky events (0x03, read-to-clear): attach/detach, suspend_start/end, usb_reset, rx_err, pid_cs_err, crc5_err, nse_err\n  - LineState_r and VStatus_r captured in phy_clk and exposed via RF for software diagnostics\n\n- Cross-domain considerations\n  - Link status (usb_suspend/mode_hs/attached) generated in phy_clk; reported in clk_i via synchronized/sticky registers\n  - Remote-wakeup request (rf_resume_req) crosses clk_i → phy_clk as one-shot; cleared by suspend_clr feedback\n\n- UTMI transmit gating at boundaries\n  - usbf_utmi_if ensures TxValid/TxReady handshake at SOP/last byte; integrates drive_k so DataOut is neutralized and valid pulses occur even when TxReady is withheld during special OpModes\n\n- Recommended software flow\n  - Monitor inta_o/intb_o; read 0x03 to identify/clear link stickies; read 0x00 for live state\n  - After usb_reset sticky, reinitialize device address/config as required by system policy\n  - For remote wake: ensure suspend has lasted per USB timing, then write MAIN_CSR bit[5]; no explicit deassert needed (one-shot)\n\n- Notes and limitations\n  - Resets are synchronous by default (USBF_ASYNC_RESET optional)\n  - HS Test Modes (USB 2.0 certification) are not implemented\n  - SuspendM polarity/behavior should be verified against the target PHY datasheet"
    },
    "Operation": {
        "Reset and Initialization Sequence": "Reset and Initialization Sequence\n- Reset sources and domains\n  - External system reset rst_i drives both core domains: rst (phy_clk) and phy_rst_pad_o; default behavior is synchronous reset in all modules (USBF_ASYNC_RESET optional for select flops in UTMI/PD paths)\n  - Runtime bus reset (USB SE0) is detected by the UTMI link-state FSM (usbf_utmi_ls) and asserted as usb_reset; this re-enters the link negotiation sequence but does not assert rst_i\n\n- Global reset effects (on rst_i assertion)\n  - usbf_utmi_if / usbf_utmi_ls (phy_clk)\n    • Enter POR state: force Full-Speed view (XcvSelect=FS), enable FS termination (TermSel=1), OpMode=Normal (bit-stuff on), mode_hs=0, usb_attached=0, usb_suspend=0\n    • Tx side held idle: TxValid=0; DataOut neutralized when special modes drive_k may be used later\n  - usbf_pl / data path (phy_clk)\n    • All protocol engines idle; timeouts/sequence state cleared; PID/CRC checkers reset (e.g., CRC16 seed=16'hFFFF at next packet start)\n    • IDMA idle: mreq=0, mwe=0; counters/flags (sizu_c/sizd_c/send_data/idma_done) cleared\n  - usbf_mem_arb (phy_clk)\n    • wack_r cleared; sram_we=0; selection defaults to M-side when active, otherwise W-side combinationally (sram_re tied high)\n  - usbf_rf (clk_i for bus view, phy_clk for core view)\n    • Global RF registers cleared: MAIN_CSR read fields reflect 0; INT_MASKS=0; INT_SOURCES=0; UTMI vendor ctrl=0\n    • Per-EP register files reset: CSR fields cleared/disabled; BUF0/BUF1 and buf0_orig set to 32'hFFFF_FFFF (invalid sentinel); per-EP sticky INTs cleared; DMA counters idle\n  - usbf_wb (phy_clk FSM, wb_clk ACK pipeline)\n    • FSM to IDLE; no outstanding request; ACK one-shot pipeline cleared; wb_data_o reset\n  - Top-level\n    • susp_o <= 0 (tracks usb_suspend); resume_req_r cleared; LineState_r/VStatus_r captured from UTMI on next activity\n\n- Power-on initialization timeline (after rst_i deassert)\n  1) Link attach qualification\n     • usbf_utmi_ls transitions POR → ATTACH; after ~100 ms debounce, usb_attached=1 → NORMAL (FS view)\n  2) Software bring-up over Wishbone\n     • Read MAIN_CSR (0x00) and INT_SOURCES (0x03) to confirm clean state; reading 0x03 also clears any stickies\n     • Program FUNC_ADDR (0x01) per enumeration; note: Chapter 9 address reset on bus reset is not auto-enforced—firmware should restore address 0 when required\n     • Configure RF INT masks (0x02) and per-EP INT enables; clear per-EP INTs by reading EPn_INT\n     • For each enabled endpoint: program EPn_CSR (direction/type/MPS/DMA), write BUF0/BUF1 descriptors (address/size), and enable DMA if used\n  3) Operation start\n     • Endpoints remain idle until host tokens arrive; protocol engine and IDMA arbitrate SRAM via fixed-priority mem_arb\n\n- Runtime USB bus reset handling (SE0 observed)\n  - usbf_utmi_ls asserts usb_reset and enters RESET state; OpMode=Disable bit-stuff/NRZI; FS termination enabled\n  - After ~1 ms, device performs HS negotiation (chirp K) and observes host K/J alternation; on six chirps → SPEED_NEG_HS (mode_hs=1, HS selected); otherwise SPEED_NEG_FS\n  - Upon completion, NORMAL state resumes in the negotiated speed; software typically re-initializes function address and any policy required after bus reset (not hardware-forced)\n\n- Suspend/resume interaction (for completeness)\n  - On long idle, usb_suspend=1; SuspendM deasserts to place PHY in low power; susp_o reflects suspend in clk_i domain\n  - Host resume (K) or function remote-wake (write MAIN_CSR bit[5]) triggers RESUME sequence: wait ~5 ms (remote wake), drive K ~1 ms, settle ~100 µs, then return to NORMAL; suspend_clr pulses to clear resume_req_r\n\n- Cross-domain and handshake reset states\n  - DMA req/ack bridges start idle: dma_req_o=0 until EP logic raises requests; ack toggles are synchronized before use\n  - Wishbone ACK one-shot pipeline is cleared; first completed RF/MA access will generate a clean single wb_clk ACK pulse\n\n- Software checklist after reset/bus reset\n  - Verify MAIN_CSR.suspend=0, mode_hs reflects negotiated speed, usb_attached=1\n  - Clear RF stickies by reading 0x03; reprogram FUNC_ADDR (0x01) and any policy registers if bus reset occurred\n  - Restore endpoint CSRs/descriptors as needed; unmask interrupts\n\n- Notes/limitations\n  - Resets are synchronous by default; some UTMI/PD flops support optional async reset via USBF_ASYNC_RESET\n  - Hardware does not enforce Chapter 9 address reset-to-zero on bus reset; firmware responsibility\n  - HS Test Modes via SetFeature(TEST_MODE) are not implemented",
        "Attach/Detach, USB Reset, and Speed Negotiation": "Attach/Detach, USB Reset, and Speed Negotiation\n- Attach/Detach detection (phy_clk)\n  - Gated by usb_vbus and LineState in the UTMI link-state FSM (usbf_utmi_ls)\n  - Power-on → POR → ATTACH; after ~100 ms debounce the core sets usb_attached=1 and enters NORMAL\n  - Detach is latched on loss of attach (falling edge); both attach and deattach edges are reported as RF-level sticky events\n  - Software visibility: MAIN_CSR (0x00) bit[2]=usb_attached; INT_SOURCES (0x03) sticky bits [5]=attach, [6]=deattach (read-to-clear)\n\n- USB Reset detection (phy_clk)\n  - Qualified SE0 window in NORMAL triggers RESET state and asserts usb_reset\n  - UTMI control during RESET: OpMode=2'b10 (disable bit-stuff/NRZI), FS termination enabled (TermSel=1), receive path forced to FS (XcvSelect=FS)\n  - After ~1 ms in RESET, the core proceeds to speed negotiation\n  - Software visibility: MAIN_CSR (0x00) reflects live line_state; INT_SOURCES (0x03) bit[8]=usb_reset sticky (read-to-clear)\n\n- High-Speed (HS) negotiation (chirp sequence)\n  - SPEED_NEG: device drives K (drive_k=1) while in FS view, then observes host chirps\n  - Host chirp detection states SPEED_NEG_K / SPEED_NEG_J count qualified alternating K/J edges; on six chirps → SPEED_NEG_HS, else → SPEED_NEG_FS\n  - Entering HS: OpMode=2'b00 (normal), select HS receiver (XcvSelect=0 per code), disable FS termination (TermSel=0), mode_hs=1\n  - Fallback to FS: OpMode=2'b00, select FS receiver (XcvSelect=1), TermSel=1, mode_hs=0\n  - Timing references (macro-driven, ~250 ns tick base): ~1.2 ms chirp window, ~1 ms RESET pre-chirp, ~100 µs settle after resume/negotiation\n  - Software visibility: MAIN_CSR (0x00) bit[1]=mode_hs\n\n- State hygiene and transitions\n  - NORMAL (FS) idle defined as J; NORMAL (HS) idle defined as SE0; long-idle logic also feeds suspend entry/exit (reported separately)\n  - After negotiation, the FSM returns to NORMAL in the negotiated speed; line control pins (XcvSelect, TermSel, OpMode) reflect the active mode\n\n- Interrupt/reporting integration (clk_i bus view)\n  - RF-level sticky events at 0x03: attach, deattach, usb_reset captured and cleared on read; masks at 0x02 route these to inta_o/intb_o independently\n  - MAIN_CSR (0x00) provides live {suspend, mode_hs, usb_attached, line_state[1:0]}\n\n- Behavioral notes / limitations\n  - Attach debounce ~100 ms; reset and chirp windows use constant macros; exact real-time values depend on clock/macro configuration\n  - Bus reset does not force device address back to 0 in hardware; firmware must restore address and policy as required\n  - USB 2.0 HS Test Modes (SetFeature(TEST_MODE)) are not implemented",
        "Suspend/Resume and Remote Wakeup": "Suspend/Resume and Remote Wakeup\n- Entering suspend (phy_clk)\n  - Idle detection in usbf_utmi_ls:\n    • FS: idle = J; HS: idle = SE0\n    • After a qualified long idle (T1_gt_3_0_mS), the FSM asserts usb_suspend and enters SUSPEND\n  - UTMI power control:\n    • SuspendM deasserted when suspended (places PHY in low power)\n    • Line control pins held appropriate to low-power state\n  - Status exports:\n    • usb_suspend (phy_clk) reflects core suspend; top-level susp_o mirrors it in clk_i domain\n    • MAIN_CSR (0x00) bit[0] = suspend (live)\n    • INT_SOURCES (0x03) stickies: [3]=suspend_start, [4]=suspend_end (read-to-clear)\n\n- Host-initiated resume (phy_clk)\n  - Detection: qualified K signaling (k_long) while suspended\n  - Sequence:\n    • FSM transitions to RESUME, clears usb_suspend\n    • Waits for SE0, restores OpMode=2'b00 (Normal), selects HS/FS xceiver per previous mode, adjusts TermSel accordingly\n    • Settles in RESUME_WAIT for ~100 µs before returning to NORMAL\n  - UTMI/data gating:\n    • usbf_utmi_if guarantees TxValid handshake integrity at boundaries; DataOut neutralized during special modes\n\n- Function-initiated remote wakeup (clk_i → phy_clk)\n  - Software trigger:\n    • Write 1 to MAIN_CSR (0x00) bit[5] to pulse rf_resume_req (one-shot)\n    • rf_resume_req crosses to phy_clk and is latched as resume_req_r; auto-cleared on suspend exit via suspend_clr\n  - Timing and signaling in usbf_utmi_ls:\n    • Enforce T2_wakeup ≈ 5 ms minimum suspend time before resume\n    • Enter RESUME_REQUEST (prep), then RESUME_SIG: drive K (drive_k=1) for ~1 ms with OpMode=2'b10 (Disable bit-stuff/NRZI), FS termination enabled\n    • Transition to RESUME: clear usb_suspend, restore OpMode=2'b00, reselect HS/FS as needed, settle ~100 µs, then NORMAL\n  - Software notes:\n    • Ensure remote-wakeup is only issued while suspended and after required delay; hardware enforces the delay/drive windows\n\n- Cross-domain and reporting\n  - susp_o provides system-visible suspend state in clk_i domain\n  - INT routing: suspend_start/end stickies at 0x03 masked independently to inta_o/intb_o via 0x02\n  - Live link fields at MAIN_CSR (0x00): {suspend, mode_hs, usb_attached, line_state[1:0]}\n\n- UTMI control pins by state (summary)\n  - SUSPEND: SuspendM deasserted; xceiver select/termination held stable\n  - RESUME_SIG: drive_k asserted; OpMode=2'b10; FS termination enabled\n  - RESUME/NORMAL: OpMode=2'b00; XcvSelect and TermSel reflect HS/FS mode; mode_hs maintained\n\n- Timings (macro-driven, ~250 ns tick base)\n  - Suspend qualify ≈ 3.0 ms idle; remote-wake delay ≈ 5 ms; resume K drive ≈ 1.0 ms; settle ≈ 100 µs\n\n- Limitations/notes\n  - SuspendM polarity depends on PHY (intended: high = not suspended); verify with target PHY\n  - Remote wake authorization policy (descriptor/config) is firmware responsibility; hardware provides mechanism and timing enforcement",
        "Receive Path Operation": "Receive Path Operation\n- Front-end capture (UTMI → core, phy_clk)\n  - usbf_utmi_if registers UTMI RxValid, RxActive, RxError, and DataIn on every phy_clk; delivers clean rx_valid, rx_active, rx_err, rx_data to the protocol layer\n  - Link-state controller (usbf_utmi_ls) runs in parallel for attach/reset/suspend; RF-level sticky rx_err_r is exposed at 0x03[7]\n\n- Packet decode and integrity checks (usbf_pd)\n  - PID handling: latches the first byte PID, verifies 1’s-complement; pid_cks_err asserted on mismatch\n  - Token decode (OUT/IN/SETUP/SOF/PING): captures two header bytes, extracts function address (token_fadr[6:0]), endpoint (token_endp[3:0]), SOF frame_no[10:0]; computes CRC5 and flags crc5_err on token_valid\n  - DATA decode (DATA0/1/2/MDATA): two-byte pipeline aligns rx_data_st[7:0] with rx_data_valid; rx_data_done strobes at end-of-payload\n  - CRC16 check: running CRC (init 16'hffff) over payload+CRC bytes; at rx_data_done, crc16_err flags non-residue (≠16'h800d)\n  - token_valid pulses on header complete (and on ACK seen) to time protocol reactions\n\n- Address/endpoint match and filtering (usbf_pl)\n  - Match gating: fsel = (token_fadr == funct_adr); match_o = fsel & applicable PID & token_valid & !crc5_err & !pid_bad\n  - pid_bad filters non-address-bearing/irrelevant PIDs (e.g., ACK/NAK/STALL/NYET/PRE/ERR/SPLIT); PING only in HS\n\n- OUT/SETUP receive policy and handshakes (usbf_pe)\n  - On valid OUT/SETUP match: check endpoint CSR policy (direction, MPS, sml_ok/lrg_ok) and buffer availability\n  - If allowed: assert rx_dma_en to start RX DMA; else select NACK/STALL per policy and HS rules\n  - End-of-packet: choose handshake (ACK/NACK/NYET for HS) based on errors, size policy, and buffer state\n  - Special conditions:\n    • out_to_small asserted for HS OUT with DMA when received size != MPS (short packet)\n    • pid_seq_err on unexpected DATA PID; iso: flag and proceed; non-iso: ACK but discard (no descriptor update)\n    • nse_err when token is for another endpoint/address (exported as RF sticky)\n\n- Receive DMA engine (usbf_idma)\n  - Alignment-aware RX write path:\n    • On RX start: issue a word read (WAIT_MRD) to seed dtmp_r for read-modify-write of the first unaligned word\n    • Assemble incoming bytes into dtmp_r by lane, using initial byte offset adr_cb\n    • word_done pulses on each completed 32-bit word; drive mwe and write mdout at word boundaries\n    • After rx_data_done, wr_last ensures final partial word is flushed\n  - Handshake to memory: mreq/mack with write-enable mwe; madr presents word address; mdout write data\n  - Counters/flags: sizu_c counts received bytes; idma_done marks RX end\n  - Ring/wrap addressing when dma_en is set; address wraps at adr + buf_size\n\n- Descriptor update and buffer bookkeeping (usbf_pe → usbf_rf)\n  - After RX completion: compute new_size/new_adr and write back via idin to BUF0/BUF1 as selected; buf*_set strobes commit descriptor\n  - For non-DMA OUT, advance by sizu_c; for DMA OUT, advance by MPS (except out_to_small: preserve original address, write sizu_c)\n  - uc_bsel_set/uc_dpd_set optionally update software-visible buffer select and PID base/toggle; buf0_rl used to release DMA buffer ownership where applicable\n\n- Interrupts and reporting\n  - Per-EP INT (read-to-clear) captures:\n    • int_crc16_set (DATA CRC error), int_seqerr_set, int_to_set (timeout), int_upid_set (unexpected PID), int_buf0_set/int_buf1_set (buffer events), out_to_small\n  - RF-level sticky events at 0x03: crc5_err_r (bit0), pid_cs_err_r (bit1), nse_err_r (bit2), rx_err_r (bit7), usb_reset (bit8); masks at 0x02 route to inta_o/intb_o\n\n- Timing and timeouts (usbf_pe)\n  - tx_data_to monitors receive activity during OUT; cleared by rx_active; threshold depends on HS/FS defines\n  - Isochronous paths bypass retries; bulk/interrupt follow standard timeout/handshake behavior\n\n- Clocking, arbitration, and CDC\n  - Entire RX path (UTMI capture, PD/PE/IDMA, mem_arb) runs in phy_clk; RF bus view and software registers in clk_i\n  - usbf_mem_arb grants M-side (protocol/DMA) absolute priority to meet RX timing; W-side accesses are served only when idle\n  - RF per-EP updates/reads are gated by ep_match; DMA req/ack handshakes cross domains with robust one-shots\n\n- Software considerations\n  - Program EPn_CSR and BUF0/BUF1 before enabling endpoints; DMA enable and buffer sizes must reflect available SRAM windows\n  - On receive-related interrupts, read EPn_INT to determine cause and clear; for link-level errors (CRC5/PID/nse/rx_err), read 0x03 to clear stickies\n  - For HS OUT short-packet (out_to_small), software inspects write-back (size/count) and may re-arm descriptors per policy",
        "Transmit Path Operation": "Transmit Path Operation\n- Host IN token handling and transmit decision (phy_clk)\n  - usbf_pd asserts pid_IN and token_valid on a valid IN token\n  - usbf_pe checks match_o (function address/EP), endpoint CSR policy, buffer/ DMA readiness (dma_in_buf_sz1)\n  - If permitted, usbf_pe selects DATA PID (DATA0/1/2/MDATA), may request zero-length (ZLP) per CSR/MPS, and asserts tx_dma_en to start TX; otherwise returns NACK/STALL per policy\n\n- TX DMA source path (usbf_idma)\n  - Starts on tx_dma_en with adr/size from usbf_pe; fetches 32-bit words from SSRAM using a two-word ping-pong prefetch (rd_buf0/rd_buf1)\n  - Presents tx_data_st[7:0] to the packet assembler; rd_next pulses for each accepted payload byte\n  - send_data goes high after the first memory read completes and stays high until the last byte is consumed; supports ZLP via send_zero_length\n  - Addressing supports ring/wrap when dma_en is set; size counter (sizd_c) decrements on first-ack and each rd_next\n\n- Packet assembly and CRC (usbf_pa)\n  - On send_data: emits DATA PID first, streams payload bytes, then two CRC16 bytes (computed with usbf_crc16, reflected and ones-complemented; low CRC byte first)\n  - Zero-length case: DATA PID followed immediately by CRC (no payload)\n  - Handshake packets: when send_token asserted by usbf_pe, outputs a single PID byte (ACK/NACK/STALL/NYET) without asserting tx_valid; tx_valid_last marks this one-byte transfer\n  - Control and flags: tx_first pulses at SOP; tx_valid asserted during DATA PID, payload, and CRC; tx_valid_last asserted on the final CRC byte (and for single-byte handshakes)\n\n- UTMI transmit handshake and PHY integration (usbf_utmi_if)\n  - Preloads first byte at SOP (tx_first) so DataOut is valid when TxValid rises\n  - Holds TxValid until TxReady, guaranteeing UTMI TxValid/TxReady handshake; tx_valid_last ensures the last beat is seen\n  - During special link signaling (resume/chirp via drive_k), DataOut is neutralized and TxValid is pulsed appropriately even if TxReady is low\n\n- ACK wait and completion (usbf_pe with usbf_pd feedback)\n  - After DATA transmission, non-iso IN paths wait for host ACK (state IN2); timeout tracked by rx_ack_to with HS/FS thresholds\n  - On ACK (token_valid + pid_ACK from usbf_pd) or timeout, usbf_pe proceeds to descriptor updates and status reporting\n\n- Descriptor write-back and buffer state (usbf_pe → usbf_rf)\n  - Computes new_size/new_adr after a successful/terminal transmit and writes back via idin to BUF0/BUF1; buf*_set strobes commit descriptor\n  - For DMA IN, buffer_done indicates buffer empty (new_size == 0); buf0_rl may be asserted to release buffer ownership when DMA is used\n  - uc_bsel_set/uc_dpd_set optionally update software-visible buffer select and PID base/toggle\n\n- Arbitration and memory access (usbf_mem_arb)\n  - M-side (protocol/DMA) has absolute priority over W-side (Wishbone) to maintain continuous TX throughput; read data is broadcast to both sides\n\n- Interrupts and status\n  - Per-EP INT (read-to-clear) records: int_buf0_set/int_buf1_set (buffer events), int_to_set (ACK wait timeout), int_seqerr_set (sequence), int_upid_set (unexpected PID), int_crc16_set (RX side), and others per endpoint policy\n  - RF-level stickies (0x03) cover link/status events; MAIN_CSR (0x00) holds live link fields; inta_o/intb_o routing by 0x02 masks\n\n- Timing and modes\n  - HS/FS timing windows (ACK wait, inter-packet expectations) are enforced via counters defined by macros; DATA PID selection enforces data toggle rules per CSR/uc_dpd\n  - Isochronous IN transmits without waiting for ACK/retry; bulk/interrupt follow normal retry/timeout semantics\n\n- Software considerations\n  - Before enabling an IN endpoint, program EPn_CSR and BUF0/BUF1 descriptors; ensure DMA capacity allows at least one max packet (dma_in_buf_sz1)\n  - Handle TX completion via EPn_INT buffer event bits; on timeouts or sequence issues, inspect EPn_INT and update descriptors/policy as required\n  - For ZLP needs (e.g., control status stage or MPS==0), ensure usbf_pe is configured to assert send_zero_length when selected",
        "Endpoint Policy and Buffer Management": "Endpoint Policy and Buffer Management\n- Per-endpoint control/status (CSR)\n  - Direction/type/state:\n    • csr[27:26]: endpoint direction/type (01=IN, 10=OUT; CTRL handled internally by policy)\n    • csr[25:24]: transfer type (iso/bulk/interrupt) for policy/timing\n    • csr[23:22]: state (disable/stall)\n  - Packet sizing/scheduling:\n    • csr[10:0]: MaxPacketSize (MPS)\n    • csr[12:11]: tr_fr (HS isochronous microframe scheduling)\n  - DMA/policy bits:\n    • csr[15]: dma_en (non-CTRL endpoints)\n    • csr[17]: lrg_ok (OUT may exceed MPS)\n    • csr[16]: sml_ok (OUT may be short of MPS)\n    • ots_stop (bit13): latch behavior on HS OUT short (out_to_small)\n  - Software-visible toggles:\n    • uc_bsel[1:0] (CSR MSBs): SW buffer select base/toggle\n    • uc_dpd[1:0] (CSR MSBs): SW data PID base/toggle policy\n\n- Buffer model (per EP)\n  - Two 32-bit descriptors: BUF0/BUF1 hold {address, size}; reset to 0xFFFF_FFFF\n  - buf0_orig mirrors last SW write to BUF0 and defines DMA capacity/limit (words)\n  - Buffer select policy:\n    • DMA-enabled: always BUF0 (fixed DMA path)\n    • CTRL endpoints: IN uses BUF1, OUT/SETUP uses BUF0\n    • Non-DMA data: prefer uc_bsel; auto-switch if current buffer NA; avoid BUF1 if NA\n\n- Buffer updates and write-back (transaction completion)\n  - Common selection: usbf_pe chooses active buffer per policy/availability\n  - Address/size update rules:\n    • IN: new_size = buf_size − size_next; new_adr = adr + size_next\n    • OUT + DMA: new_size uses MPS; new_adr += MPS (host sends full MPS)\n    • OUT + non-DMA: new_size = buf_size − sizu_c; new_adr += sizu_c\n  - Special case HS OUT short (out_to_small): write back sizu_c; preserve original address (no advance)\n  - Commit sequence:\n    • idin carries new fields; buf0_set/buf1_set strobes write descriptor\n    • uc_bsel_set/uc_dpd_set update SW-visible toggles in CSR low bits\n    • buf0_rl releases DMA buffer ownership when buffer_done and dma_en\n\n- Data PID policy\n  - this_dpid/data_pid_sel derived from endpoint type, transfer type, mode_hs (HS), tr_fr, and uc_dpd\n  - next_dpid stored back for subsequent transactions; iso rules limit permitted PIDs\n  - pid_seq_err on OUT when expected vs received DATA PID mismatch:\n    • Iso: raise int_seqerr_set, proceed to update (no retry/handshake)\n    • Non-iso: ACK and discard (no descriptor update)\n\n- Handshake/flow-control policy (OUT/SETUP)\n  - If policy/space not satisfied: NACK or STALL based on endpoint state/policy\n  - HS-specific: PING is ACKed; NYET returned when buffers not ready\n  - NSE (not-selected endpoint) events flagged but not claimed\n\n- DMA accounting and readiness (clk domain core view in usbf_rf)\n  - OUT direction counters: dma_out_cnt increments by P (MPS in words) per set event; decrements per dma_ack; dma_out_buf_avail indicates capacity for at least one MPS\n  - IN direction counters: dma_in_cnt increments per dma_ack; decrements by P per set event; dma_in_buf_sz1 asserts when at least one MPS is ready\n  - DMA req/ack bridge (wclk side): dma_req holds across bursts via hold logic; deasserts after ack when safe\n\n- Endpoint match gating\n  - All in-band updates (buf*_set, uc_*_set, interrupts) apply only when ep_match is true (selected EP)\n  - usbf_rf muxes the currently matched EP’s CSR/BUF view to the core and exports dma_in_buf_sz1/dma_out_buf_avail\n\n- Abort/overflow and size policy\n  - buffer_overflow = sizu_c > buf_size during OUT sets abort\n  - to_small/to_large derived from sml_ok/lrg_ok and received size\n  - New matches while busy can force local abort to return endpoint to IDLE\n\n- Interrupts and event reporting\n  - Per-EP INT (read-to-clear) sticky sources:\n    • int_buf0_set/int_buf1_set (buffer events), int_to_set (timeout), int_seqerr_set, int_upid_set (unexpected PID), int_crc16_set (RX CRC), out_to_small\n  - RF-level sticky events (0x03): attach/detach, suspend start/end, usb_reset, rx_err, pid_cs_err, crc5_err, nse_err\n  - Mask routing (0x02) independently to inta_o/intb_o; EP A/B enables inside EPn_INT\n\n- Software programming model\n  - Program EPn_CSR (direction, type, MPS, DMA/policy) and BUF0/BUF1 descriptors via RF window; BUF0 mirrored in buf0_orig\n  - For DMA endpoints: provision buf0_orig capacity and SRAM region; ensure dma_in_buf_sz1/dma_out_buf_avail reflect readiness\n  - On completion/interrupt: read EPn_INT (clears), inspect descriptor write-backs (size/address/count), re-arm buffers and toggles as needed\n  - CTRL pipe behavior (e.g., mandatory SETUP accept) is not fully enforced by HW; firmware must ensure Chapter 9 policy\n\n- Address map (per EP window)\n  - +0: CSR (R/W)  • +1: INT (R/W, read-to-clear)  • +2: BUF0 (R/W)  • +3: BUF1 (R/W)",
        "Memory Arbitration Behavior": "Memory Arbitration Behavior\n- Topology and ports\n  - Single-port synchronous SSRAM shared by two masters:\n    • M (USB core: protocol/DMA on phy_clk)\n    • W (Wishbone/software via usbf_wb, also served in phy_clk)\n  - Data width 32-bit; address width parameterized by SSRAM_HADR\n  - sram_re is tied high; read data (sram_din) is broadcast to both masters (mdout, wdout)\n\n- Arbitration policy (usbf_mem_arb)\n  - Fixed priority: M has absolute priority; W is granted only when M is idle\n  - Selection: wsel = (wreq | wack) & !mreq keeps W selected through its ack cycle; any M request immediately de-selects W on the next cycle\n  - No fairness/parking on W; W can be starved during sustained USB activity by the core (by design to meet USB timing)\n\n- Handshake and acks\n  - M side:\n    • mack = mreq (combinational “immediate” ack); upstream M logic must align sampling to the actual SSRAM timing outside the arbiter\n  - W side:\n    • wack is a one-phy_clk-cycle pulse when granted; when W holds wreq and M stays idle, wack pulses every other phy_clk (max one accepted transfer per two cycles)\n    • If M asserts mreq, wack is suppressed immediately and W is preempted\n  - Masters must only sample read data when owning the bus and their ack is asserted (mdout/wdout mirror sram_din continuously)\n\n- Muxing to SRAM\n  - If wsel=1 (W granted): sram_adr=wadr, sram_dout=wdin, sram_we=(wreq & wwe)\n  - Else (M granted): sram_adr=madr, sram_dout=mdin, sram_we=(mwe & mreq)\n\n- Transaction model and throughput\n  - Single-beat transfers; no burst support at the arbiter\n  - M achieves continuous streaming subject to external SSRAM timing; W is rate-limited to one transfer every two phy_clk when M is idle\n  - Writes: M and W drive sram_we only while selected; W write enable is qualified by both wreq and wwe\n\n- Wishbone front-end interaction (usbf_wb)\n  - RF vs MA decode via wb_addr_i[17]; MA transactions serialized by a small FSM (IDLE, MA_RD/MA_WR, W0..W2) in phy_clk\n  - wb_ack_o is generated in wb_clk by a 3-FF edge synchronizer on the phy-side ack; for MA accesses, wb_ack_o follows ma_ack from mem_arb\n  - One outstanding WB transaction at a time; no pipelining; recommended that wb_clk == phy_clk to avoid CDC hazards\n\n- IDMA behavior at the arbiter boundary (context)\n  - Reads: IDMA holds mreq high until mack_r; writes: mreq pulses on word boundaries; this pattern leverages M priority to sustain RX/TX streaming\n\n- Reset/clocking notes\n  - Arbiter has a single registered element (wack_r) in phy_clk; all address/data/WE muxing is combinational\n  - With sram_re tied high, ensure the external SSRAM tolerates continuous read-enable or that chip-enable timing is handled externally\n\n- Practical implications\n  - USB data path (M) is guaranteed priority to meet USB timing; schedule Wishbone memory accesses when USB is idle\n  - Software must treat W accesses as best-effort under contention and expect preemption/latency spikes during active USB transfers",
        "Wishbone Transaction Sequencing and Acknowledge": "Wishbone Transaction Sequencing and Acknowledge\n- Clocks and CDC\n  - Two domains: wb_clk (Wishbone boundary) and phy_clk (internal FSM to RF/MA)\n  - Requests are sampled in phy_clk as wb_req_s1 <= (wb_stb_i & wb_cyc_i)\n  - ACK back to Wishbone is generated in wb_clk by a 3‑FF edge detector that converts a phy‑side ack strobe (wb_ack_d) into a single wb_clk‑cycle wb_ack_o pulse\n  - Best used with wb_clk == phy_clk; otherwise, request sampling is CDC‑risky (ack path is synchronized)\n\n- Address decode and regions\n  - With USBF_TEST_IMPL: wb_addr_i[17] selects region\n    • 0: RF (register file)\n    • 1: MA (memory array/SSRAM window)\n  - 32‑bit, word‑aligned port (ADR[n:2]); no SEL_I\n\n- FSM in phy_clk (single outstanding transaction)\n  - States: IDLE, MA_WR, MA_RD, W0, W1, W2\n  - IDLE:\n    • If region=MA & write: assert ma_req & ma_we → MA_WR\n    • If region=MA & read:  assert ma_req        → MA_RD\n    • If region=RF (read or write): pulse rf_re or rf_we_d → W0 (fast path)\n  - MA_WR: hold ma_req/ma_we until ma_ack; on ma_ack: wb_ack_d=1 → W1\n  - MA_RD: hold ma_req        until ma_ack; on ma_ack: wb_ack_d=1, data from ma_din → W1\n  - W0 (RF fast path): wb_ack_d=1 → W1\n  - W1 → W2 → IDLE (dead‑time spacing to ensure clean, one‑shot ACK)\n\n- Data paths and sideband strobes\n  - RF region:\n    • Writes: rf_we_d=1, rf_dout<=wb_data_i; ACK immediate (W0)\n    • Reads:  rf_re=1; wb_data_o<=rf_din at wb_clk when wb_ack_o pulses\n  - MA region:\n    • Writes: ma_req=1 & ma_we=1, ma_dout<=wb_data_i; wb_ack_o when ma_ack is seen\n    • Reads:  ma_req=1; wb_ack_o when ma_ack is seen; wb_data_o<=ma_din at that time\n\n- ACK generation (wb_clk domain)\n  - wb_ack_d (phy side) → 3‑FF edge detector → single wb_ack_o pulse per completed transaction\n  - W1/W2 spacing prevents back‑to‑back ACK hazards with the synchronizer\n  - Only ACK_O is used (no ERR/RTY); classic single‑termination Wishbone behavior\n\n- Interaction with memory arbiter (MA path latency)\n  - ma_ack is sourced by usbf_mem_arb’s W‑side grant; when the USB core (M) is active, W is de‑selected and MA transactions wait\n  - When M is idle and W holds request, the arbiter paces grants roughly one every two phy_clk cycles, bounding best‑case MA throughput\n\n- Operational characteristics\n  - Single outstanding transfer; no pipelining or bursts\n  - Read data must be valid at the wb_clk edge where wb_ack_o pulses (RF: rf_din; MA: ma_din)\n  - Writes complete on wb_ack_o\n  - Under USB traffic, MA transactions may see added latency/preemption due to M‑side priority in the arbiter",
        "Error Detection, Reporting, and Recovery": "Error Detection, Reporting, and Recovery\n- Detection sources (by layer)\n  - UTMI/link layer (usbf_utmi_if/usbf_utmi_ls)\n    • rx_err (PHY receive error) → latched as rx_err_r (RF sticky at 0x03[7])\n    • usb_reset detect (SE0 window) → usb_reset sticky (0x03[8])\n    • Attach/deattach, suspend start/end → stickies at 0x03[5:3],[6],[4]\n  - Packet decode (usbf_pd)\n    • pid_cks_err (bad PID complement)\n    • crc5_err (token CRC5 mismatch)\n    • crc16_err (DATA CRC residue mismatch at end-of-payload)\n    • seq_err (protocol sequencing anomaly not flagged by PHY)\n    • token_valid for qualified header/ACK timing; nse_err (token not for this function/EP) surfaced in PL\n  - Protocol/endpoint policy (usbf_pe)\n    • nse_err (not-selected endpoint/address)\n    • to_small / to_large (OUT size vs csr.sml_ok/lrg_ok)\n    • pid_seq_err (expected vs received DATA PID on OUT)\n    • Timeouts: rx_ack_to (IN ACK wait), tx_data_to (OUT data activity)\n    • out_to_small (HS OUT+DMA short; size != MPS)\n    • buffer_overflow (sizu_c > buf_size while receiving)\n  - DMA/arbiter context (usbf_idma/usbf_mem_arb)\n    • IDMA aborts on overflow/policy violations; W-side (Wishbone) has no error signaling (no ERR/RTY), only ACK pacing\n\n- Reporting (interrupts and status)\n  - Per-endpoint INT (EPn_INT; read-to-clear inside EP block)\n    • int_crc16_set (DATA CRC error at end of RX)\n    • int_seqerr_set (sequence/data-toggle error)\n    • int_to_set (timeout: IN ACK wait or OUT data inactivity)\n    • int_upid_set (unexpected/illegal PID for this EP)\n    • int_buf0_set / int_buf1_set (buffer events)\n    • out_to_small (HS OUT short-packet policy)\n    • Enables: iena/ienb (A/B) in EPn_INT gate per-EP sources to inta_o/intb_o via aggregation in RF\n  - RF-level sticky events (usbf_rf @ 0x03; read-to-clear)\n    • [8] usb_reset, [7] rx_err_r, [6] deattach, [5] attach, [4] suspend_end, [3] suspend_start\n    • [2] nse_err_r, [1] pid_cs_err_r, [0] crc5_err_r\n    • Routing masks at 0x02 (inta_msk/intb_msk) independently gate these to inta_o/intb_o\n  - Live link/diag\n    • main_csr (0x00): {suspend, mode_hs, usb_attached, line_state}\n    • frm_nat (0x04): SOF/microframe timestamp for timing/debug\n\n- Recovery and policy actions\n  - Handshake selection on errors (usbf_pe)\n    • Policy violations (to_small/to_large), buffer unavailable, CTRL wrong direction: NACK\n    • Endpoint stalled: STALL\n    • HS no-buffers on OUT: NYET\n    • Unexpected PID (upid): NACK/STALL per endpoint state; event latched\n  - DATA PID sequence errors (pid_seq_err)\n    • Isochronous OUT: raise int_seqerr_set, proceed to descriptor update (no retry/handshake beyond ISO rules)\n    • Non-iso OUT: send ACK to keep host moving, discard packet (no descriptor update)\n  - CRC errors\n    • DATA CRC16 error: int_crc16_set; OUT packet effectively discarded; handshake per endpoint type/policy\n    • TOKEN CRC5/PID complement errors: ignored for transaction; RF stickies pid_cs_err_r/crc5_err_r record condition\n  - Timeouts\n    • IN: rx_ack_to expiration (HS/FS thresholds) → int_to_set; transaction ends, descriptors updated accordingly\n    • OUT: tx_data_to (no receive activity) → int_to_set; abort receive and return to IDLE\n  - Address/endpoint mismatch\n    • nse_err observed but transaction not claimed; RF sticky nse_err_r set for software\n  - Short-packet policy (HS OUT + DMA)\n    • out_to_small asserted when received size != MPS\n    • Write-back preserves original address and writes sizu_c (no address advance); out_to_small interrupt/sticky\n  - Abort paths and state recovery\n    • buffer_overflow or new-match while busy → abort path forces OUT back to IDLE\n    • Any new addressed match can asynchronously return engine to IDLE next cycle to service the new transaction\n\n- Descriptor/state updates after error or completion\n  - Normal completion: idin carries {buffer_done,new_size,new_adr}; buf*_set strobes commit; uc_bsel_set/uc_dpd_set update SW-visible selects/PID base; buf0_rl releases DMA buffer when applicable\n  - Error-specific handling:\n    • pid_seq_err (non-iso): no descriptor update despite ACK\n    • out_to_small: idin writes {0,sizu_c} and preserves original address\n\n- Firmware and system responsibilities\n  - Service per-EP interrupts via EPn_INT (read-to-clear); inspect descriptors to determine buffer advancement or re-arming\n  - Service RF-level stickies at 0x03 (read-to-clear) for link/parse issues (PID/CRC5/NSE/RXERR/RESET/attach/suspend)\n  - Configure masks: EP-level (A/B enables) and RF-level (0x02 inta/intb) to route desired causes to inta_o/intb_o\n  - Control-pipe (EP0) corner cases (SETUP always-accept, length-mismatch STALL, DATA0 re-init on halt clear) are not fully enforced in HW; implement recovery/compliance in firmware\n  - Under bus reset (usb_reset sticky), reinitialize device state in firmware as required by system policy (address reset behavior is not enforced by RTL)\n\n- Link-level recovery\n  - Suspend/resume handled by usbf_utmi_ls: generates resume signaling (drive K), manages timing windows, and exposes usb_suspend/suspend_clr for coordinated SW/stack recovery\n  - HS negotiation fallbacks (chirp counting); falls back to FS if negotiation fails; status reported in mode_hs\n",
        "Timing and Latency Considerations": "Timing and Latency Considerations\n- Clocks and domains\n  - Two primary domains: phy_clk (UTMI/protocol/DMA/memory arbiter/RF core view) and wb_clk (Wishbone + RF bus view)\n  - Resets are synchronous by default; optional USBF_ASYNC_RESET gates some flops but is not assumed here\n  - CDC points:\n    • Wishbone: requests sampled directly in phy_clk; ACK returned to wb_clk through a 3‑FF edge detector (single‑cycle wb_ack_o pulse)\n    • RF vendor/resume and DMA req/ack use one‑shot/toggle synchronizers between wclk and clk\n\n- UTMI byte‑level transmit/receive timing\n  - Transmit handshake guarantees:\n    • tx_first preloads the first byte so DataOut is valid when TxValid rises (minimizes SOP latency)\n    • TxValid held until TxReady for data bytes; tx_valid_last forces a final beat to be seen even if tx_valid drops early\n    • During drive_k (resume/chirp), TxValid is pulsed boundedly (disabled hold next cycle) to meet special UTMI OpMode behavior\n  - Receive path registers RxValid/Active/Error and DataIn for one‑cycle stable core inputs\n\n- Protocol engine time bases and counters\n  - All protocol timing uses constant counters in phy_clk with ~250 ns tick aggregation to µs/ms windows\n  - IN ACK wait timeout (rx_ack_to): HS ~22 cycles; FS ~36 cycles (phy_clk cycles; actual time depends on clk)\n  - OUT data activity timeout (tx_data_to): HS/FS thresholds similarly defined via macros\n  - SOF/microframe timing: frm_nat timestamps frame + microframe cadence and sub‑frame time (125 µs HS microframes, 1 ms FS frames)\n\n- Link‑state and resume/reset latencies (UTMI line‑state FSM)\n  - Attach debounce: ~100 ms\n  - Suspend detect: gated by idle_long (ms‑scale, macro‑defined)\n  - Resume signaling: drive K for ~1 ms; settle ~100 µs before returning to NORMAL\n  - Bus reset detect (SE0 window): µs‑to‑ms windows via T1/T2 timers\n  - HS negotiation: device chirp window ~1.0–1.2 ms; host chirp counting (6 toggles) to enter HS; fallback to FS if not satisfied\n\n- DMA path latency/throughput (usbf_idma)\n  - TX (memory→USB):\n    • tx_dma_en → MEM_RD1 issues first read; first mack_r asserts send_data (start of payload availability)\n    • MEM_RD2 fills second buffer; steady state MEM_RD3 prefetches on word boundary (adrb_is_3 && rd_next) to sustain streaming\n    • First‑byte latency: one memory read round‑trip before payload flows; thereafter byte‑per‑cycle gated by tx_ready\n  - RX (USB→memory):\n    • Initial WAIT_MRD reads first word to seed read‑modify‑write for unaligned starts (adds one read latency)\n    • Full words written as they assemble; final partial word flushed after rx_data_done\n  - ZLP: send_zero_length bypasses payload; only CRC follows DATA PID (minimal tail latency)\n\n- Memory arbitration effects (single‑port SSRAM)\n  - M (USB core) has absolute priority; W (Wishbone) only when M idle\n  - W grants pace: at most one accepted transfer every two phy_clk cycles (wack pulses every other cycle)\n  - M path mack = mreq (combinational) adds no internal wait; overall latency dominated by external SSRAM timing\n  - Under heavy USB traffic, W latency is unbounded (starvation possible by design to preserve USB timing)\n\n- Wishbone transaction timing\n  - RF region: fast path ACK in W0 (appears as single completed cycle to wb_clk after synchronizer)\n  - MA region: ACK follows ma_ack from mem_arb/MEM; PHY FSM adds W1/W2 dead‑time cycles to ensure one‑shot ACK\n  - Single outstanding transaction; no pipelining/bursts; recommended wb_clk == phy_clk to avoid request CDC hazards\n\n- Endpoint policy influences on latency\n  - Isochronous IN/OUT: no retry/ACK wait (lower tail latency); bulk/interrupt wait for ACK and may retry per host policy\n  - HS features (PING/NYET) add control exchanges but protect data path by avoiding wasted OUT payloads when buffers not ready\n\n- Throughput continuity and backpressure\n  - usbf_pa + idma sustain byte‑per‑cycle streaming when tx_ready asserted and prefetch is maintained; rd_next aligns acceptance to downstream readiness\n  - send_data deasserts exactly on last‑byte consumption (sizd_c==1 + rd_next) to cleanly terminate the stream\n  - RX path performs RMW only at start and flush at end; steady‑state word writes proceed on assembled words\n\n- Software‑visible timing artifacts\n  - frm_nat (0x04) provides SOF‑relative timing for diagnostics/latency measurements\n  - main_csr exposes live link state (suspend/HS/attached/line_state) enabling firmware timing decisions during power states\n  - RF‑level stickies at 0x03 timestamp asynchronous link events (attach/detach/suspend/reset) with read‑to‑clear semantics\n\n- Practical guidance\n  - Align wb_clk to phy_clk when possible to minimize CDC latency/jitter on WB requests\n  - Expect elevated WB MA latency during active USB transfers; schedule bulk memory maintenance when endpoints are idle\n  - For deterministic IN latency, ensure dma_in_buf_sz1=1 (prefill ≥ one MPS) before host polls; for OUT, provision dma_out_buf_avail to avoid NYET/NACK stalls",
        "Corner Cases and Sequencing Rules": "Corner Cases and Sequencing Rules\n- Endpoint/transaction selection and handshakes\n  - New token match while busy: any fresh addressed match forces the protocol engine back to IDLE on the next clock; in-flight OUT may be aborted (abort path)\n  - Endpoint state gating:\n    • STALL set → always reply STALL on addressed tokens (non‑SOF)\n    • Wrong direction buffer or unavailable buffer → NACK (CTRL wrong direction included)\n    • HS PING on OUT → always ACK per HS rules\n    • HS OUT with no buffers ready → NYET\n    • NSE (token not for our address/EP) → not claimed; RF sticky nse_err is set, no data path action\n  - Timeout handling:\n    • IN: if ACK not seen within rx_ack_to (HS/FS thresholds), assert int_to_set and end transaction\n    • OUT: if no RX activity for tx_data_to, assert int_to_set, abort to IDLE\n\n- Data PID and ISO vs non‑ISO sequencing\n  - Expected DATA PID is computed per endpoint type/transfer type/microframe schedule and uc_dpd policy\n  - OUT pid_seq_err:\n    • Isochronous: raise int_seqerr_set and proceed to descriptor update (no retry/handshake beyond ISO rules)\n    • Non‑isochronous: return ACK to keep host moving but discard packet (no descriptor update)\n  - ISO transfers: no ACK/NAK handshakes on data; engine still reports CRC/sequence errors via interrupts\n\n- Size/policy and special packet cases\n  - to_small/to_large (OUT size vs sml_ok/lrg_ok): reply NACK and return to IDLE (non‑ISO); ISO behavior follows ISO rules (no handshake)\n  - Short HS OUT with DMA (out_to_small): write back sizu_c and preserve original address (no advance); assert out_to_small interrupt; if ots_stop is set, a status latch bit is set in CSR\n  - Buffer overflow (sizu_c > buf_size) during OUT: immediate abort of RX path; return to IDLE\n  - Zero‑length IN:\n    • If MPS==0 or ZLP requested, send DATA PID then CRC only (send_zero_length); engine still waits for ACK on non‑ISO\n\n- Buffer selection and descriptor write‑back\n  - Buffer availability and choose rules:\n    • DMA‑enabled EPs: always use BUF0\n    • CTRL EPs: IN uses BUF1; OUT/SETUP uses BUF0\n    • Non‑DMA data: prefer uc_bsel[0]; auto‑switch to the other buffer if current is not available; avoid BUF1 if NA\n  - Descriptor updates happen in two phases:\n    • UPDATE: idin carries new_size/new_adr (+buffer_done flag) and strobes buf*_set (or buf0_rl on DMA release)\n    • UPDATE2: uc_bsel_set/uc_dpd_set commit software‑visible toggles (idin[3:0] encodes next_bsel/next_dpid here)\n  - next_bsel toggle policy: toggles only when buffer_done; fixed to uc_bsel when dma_en\n  - BUF sentinel: 0xFFFF_FFFF denotes not‑available; selection logic auto‑skips NA buffers\n\n- DMA, counters, and cross‑domain sequencing\n  - Per‑packet accounting aligns to a DMA ack: set_r <= dma_ack_i & (buf0_set | buf0_rl); counters step exactly once per buffer set/reload event\n  - DMA request hold:\n    • IN: hold until within 3 words of full; OUT: hold while at least one MPS of space remains\n    • Deassert dma_req only after dma_ack and when hold condition clears\n  - RX path sequencing: first word read for RMW on unaligned starts (WAIT_MRD) before writes commence; final partial word is flushed after rx_data_done\n  - TX path sequencing: two‑word prefetch; first mack_r asserts send_data; prefetches at each word boundary (adrb_is_3 && rd_next)\n\n- Wishbone and memory arbitration corner cases\n  - Arbiter priority: M (USB core) has absolute priority; W (Wishbone) can be starved under heavy USB traffic; wack pulses every other phy_clk when served\n  - Wishbone FSM accepts one request at a time (no pipelining); RF path ACKs immediately (W0); MA path ACK waits for ma_ack then inserts W1/W2 dead‑time to ensure a one‑shot wb_ack_o\n  - CDC caveat: wb_req is sampled in phy_clk without a 2‑FF synchronizer; best practice is wb_clk == phy_clk\n  - sram_re tied high; external SSRAM must tolerate continuous read‑enable (system integration rule)\n\n- Link state and power management sequencing\n  - Attach debounce ~100 ms before NORMAL\n  - Suspend entry requires prolonged idle; exit via host K or device resume_req following ~5 ms wakeup guard; resume drives K ~1 ms then ~100 µs settle\n  - Bus reset (qualified SE0) transitions to RESET then HS chirp; HS entry requires 6 K/J toggles; fallback to FS if not met\n  - resume_req_r is auto‑cleared by suspend_clr; UTMI VControl writes always strobe VControl_Load\n\n- Interrupts and read‑to‑clear ordering\n  - RF‑level stickies at 0x03 are read‑to‑clear; software should read 0x03 after servicing per‑EP INTs to avoid missing subsequent edges\n  - Per‑EP INT (read‑to‑clear) reports buffer, timeout, CRC16, sequence, UPID, and out_to_small; A/B enables gate contributions to inta_o/intb_o\n  - Notable mapping quirk: EP INT bit[4] enable shares index with bit[3] in the code; software should program enables accordingly\n\n- Firmware responsibilities and spec deviations\n  - Control pipe (EP0) Chapter 9 behavior is not fully enforced in hardware:\n    • SETUP always‑accept, override halt, 8‑byte SETUP enforcement, length‑mismatch STALL, DATA0 re‑init on halt clear, HS Test Modes → must be handled by firmware/system policy\n  - On usb_reset sticky, firmware should reinitialize device state (including address=0) per system requirements"
    },
    "Register Map": {
        "Addressing Scheme and Regions": "Addressing Scheme and Regions\n- Top-level regions on Wishbone (wb_clk)\n  - 32-bit, word-aligned bus; no byte select. Addressing uses ADR[n:2] (byte address = 4 × word index)\n  - Region select: wb_addr_i[17]\n    • 0 = RF (Register File/control/status space)\n    • 1 = MA (Memory Array/SSRAM window)\n  - With USBF_TEST_IMPL, bus address width is 18 bits (wb_addr_i[17:0])\n\n- Register File (RF) region map (wb_addr_i[17]=0; word addresses)\n  - 0x00: MAIN_CSR (R), CTRL (W: bit[5] generates rf_resume_req one-shot)\n  - 0x01: FUNC_ADDR (R/W; device address 7 bits)\n  - 0x02: INT_MASKS A/B (R/W; per RF-event routing to inta_o/intb_o)\n  - 0x03: INT_SOURCES (R; read-to-clear sticky RF events)\n  - 0x04: FRM_NAT (R; SOF/microframe timestamp)\n  - 0x05: UTMI_VENDOR (R: VStatus latched; W: VControl[3:0] with Load strobe)\n  - Endpoint windows (per EP n = 0..15): base = 0x10 + 4*n\n    • +0: EPn_CSR (R/W)\n    • +1: EPn_INT (R/W, read-to-clear inside EP block)\n    • +2: EPn_BUF0 (R/W)\n    • +3: EPn_BUF1 (R/W)\n  - Only enabled endpoints exist in silicon (here EP0..EP3); remaining windows are reserved\n\n- Memory Array (MA) region (wb_addr_i[17]=1)\n  - 32-bit word-aligned window into shared external SSRAM\n  - Effective memory index used on WB: wb_addr_i[SSRAM_HADR+2:2]\n  - External SSRAM size (bytes) = 4 × 2^(SSRAM_HADR+1); data bus 32-bit\n\n- External SRAM/arbiter addressing (phy_clk)\n  - SRAM address bus to memory: sram_adr_o[SSRAM_HADR:0] (word index)\n  - Arbiter muxes addresses between:\n    • M side (USB core): madr[SSRAM_HADR:0] (word address)\n    • W side (Wishbone): wadr[SSRAM_HADR:0] (word address from MA window)\n\n- Descriptor and DMA address representation (clk domain)\n  - Endpoint buffer descriptors (BUF0/BUF1):\n    • Address field: bufX_adr = bufX[SSRAM_HADR+2:0] (byte address with 3 LSBs for lane/align)\n    • Size field: bufX_sz = bufX[30:17]\n  - IDMA uses byte addresses internally: adr[SSRAM_HADR+2:0] split into:\n    • adr_cw = adr[SSRAM_HADR+2:2] (word address to memory)\n    • adr_cb = adr[2:0] (byte offset within word)\n  - Write-back (idin) packing in protocol engine:\n    • idin[31:17] = {buffer_done, new_size}\n    • idin[SSRAM_HADR+2:4] = new_adr[SSRAM_HADR+2:4] (word-aligned upper bits)\n    • idin[3:0] carries either new_adr[3:0] when writing descriptors, or {next_dpid,next_bsel} during UPDATE2 of uc_* fields\n\n- Function and endpoint addressing in the protocol\n  - Function address: funct_adr[6:0] (RF 0x01); tokens match when token_fadr[6:0] == funct_adr\n  - Endpoint select: ep_sel[3:0] from token; usbf_rf exposes per-EP windows at 0x10 + 4*n aligned to endpoint number n\n\n- Parameterization and build-time knobs\n  - SSRAM_HADR: external memory address width (word index); sets sram_adr_o width and MA window depth\n  - USBF_UFC_HADR/USBF_TEST_IMPL configure WB address width and the RF/MA region select bit placement (bit 17 here)\n\n- Access rules summary\n  - RF space: control/status and per-EP CSRs/INT/BUF descriptors; single-beat WB accesses; immediate ACK for RF reads/writes\n  - MA space: packet buffer memory; single-beat WB accesses; ACK follows mem arbiter grant; USB core has priority over WB",
        "System/Core Registers": "System/Core Registers\n- Bus and access model\n  - Wishbone slave, 32-bit word-aligned (ADR[n:2]); no byte enables\n  - Register File (RF) region selected by wb_addr_i[17]=0; Memory Array (MA) by wb_addr_i[17]=1\n  - RF registers reside in clk_i (wclk) domain; many fields reflect live status from phy_clk via usbf_rf\n  - Reset defaults (sync): global RF regs clear to 0; per-EP BUF0/BUF1 = 0xFFFF_FFFF (not-available sentinel)\n\n- Global RF registers (wb_addr_i[17]=0; word addresses)\n  - 0x00 MAIN_CSR / CTRL\n    • Read (status): bit[0]=suspend, bit[1]=mode_hs, bit[2]=usb_attached, bits[4:3]=line_state[1:0]; others 0\n    • Write (one-shot control): bit[5]=1 → rf_resume_req pulse to link FSM (auto-clears)\n  - 0x01 FUNC_ADDR (R/W)\n    • Device address funct_adr[6:0] (zero-extended on read)\n  - 0x02 INT_MASKS A/B (R/W)\n    • {7'b0, intb_msk[8:0], 7'b0, inta_msk[8:0]}; gates RF-level stickies to intb_o/inta_o\n  - 0x03 INT_SOURCES (R; read-to-clear)\n    • [8]=usb_reset, [7]=rx_err_r, [6]=deattach, [5]=attach, [4]=suspend_end, [3]=suspend_start, [2]=nse_err_r, [1]=pid_cs_err_r, [0]=crc5_err_r\n  - 0x04 FRM_NAT (R)\n    • 32-bit SOF/microframe timestamp snapshot\n  - 0x05 UTMI_VENDOR (R/W)\n    • Read: {24'b0, VStatus[7:0]} latched from PHY\n    • Write: VControl[3:0] (low nibble); write also strobes VControl_Load\n\n- Per-endpoint register windows (n=0..15) at base = 0x10 + 4*n\n  - +0 EPn_CSR (R/W) — Endpoint control/status: direction, endpoint number, DMA enable, max packet size, policy bits (sml_ok/lrg_ok), STALL, uc_bsel[1:0], uc_dpd[1:0]\n  - +1 EPn_INT (R/W; read-to-clear status, write to clear/enables)\n    • Sticky causes include: int_buf0_set, int_buf1_set, int_to_set, int_crc16_set, int_seqerr_set, int_upid_set, out_to_small\n    • Enables: iena[5:0] <= din[29:24] (A path), ienb[5:0] <= din[21:16] (B path)\n    • Note: one status bit (index 4) shares enable index 3 in code; program enables accordingly\n  - +2 EPn_BUF0 (R/W) — Buffer 0 descriptor: address/length; 0xFFFF_FFFF = NA; HW write-backs size/addr\n  - +3 EPn_BUF1 (R/W) — Buffer 1 descriptor (ping-pong); same semantics as BUF0\n\n- Interrupt aggregation and read-to-clear\n  - inta_o = OR(per-EP enabled A causes) | OR(RF stickies & inta_msk)\n  - intb_o = OR(per-EP enabled B causes) | OR(RF stickies & intb_msk)\n  - 0x03 read clears RF stickies; EPn_INT read clears per-EP sticky status\n\n- Software-visible side effects\n  - MAIN_CSR write bit[5] emits rf_resume_req one-shot (no latched control)\n  - UTMI_VENDOR write always pulses VControl_Load (PHY samples VControl)\n\n- Addressing notes\n  - Word addressing (byte address = 4 × word index); only build-enabled endpoints (e.g., EP0..EP3) are implemented; others reserved\n\n- Reset defaults summary\n  - Global: MAIN_CSR=0, FUNC_ADDR=0, INT_MASKS=0, INT_SOURCES=0, FRM_NAT=0, UTMI_VENDOR control=0\n  - Per-EP: CSR/INT cleared; BUF0/BUF1 = 32'hFFFF_FFFF until programmed",
        "Interrupt Masks and Status": "Interrupt Masks and Status\n- Interrupt architecture (two layers)\n  - Per-endpoint layer: each EPn has a local INT register (sticky, read-to-clear) with its own A/B enable masks; these contribute to inta_o/intb_o via aggregation in usbf_rf\n  - RF-level layer: global/link events are latched as sticky bits and exposed at 0x03; separate A/B mask registers (0x02) route these to inta_o/intb_o\n\n- Global/RF-level registers\n  - 0x02 INT_MASKS A/B (R/W)\n    • {7'b0, intb_msk[8:0], 7'b0, inta_msk[8:0]}\n    • Masks gate RF-level sticky events (not per-EP) into intb_o/inta_o independently\n    • Reset default: all masks = 0 (masked)\n  - 0x03 INT_SOURCES (R; read-to-clear)\n    • Sticky RF events: [8]=usb_reset, [7]=rx_err_r, [6]=deattach, [5]=attach, [4]=suspend_end, [3]=suspend_start, [2]=nse_err_r, [1]=pid_cs_err_r, [0]=crc5_err_r\n    • Read side-effect clears all sticky RF bits\n  - Aggregation to outputs\n    • inta_o = OR(per-EP enabled A causes) | OR(int_srcb & inta_msk)\n    • intb_o = OR(per-EP enabled B causes) | OR(int_srcb & intb_msk)\n\n- Per-endpoint INT (EPn_INT at base 0x10 + 4*n + 1)\n  - Sticky status causes (set by protocol/PL events; read-to-clear; software may also write to clear):\n    • int_buf0_set, int_buf1_set (buffer events)\n    • int_to_set (timeout)\n    • int_crc16_set (DATA CRC16 error)\n    • int_seqerr_set (sequence/toggle error)\n    • int_upid_set (unexpected/illegal PID)\n    • out_to_small (HS OUT short-packet policy)\n  - A/B enable masks in EPn_INT (drive per-EP inta/intb up to RF aggregator):\n    • iena[5:0] <= din[29:24] (A path), ienb[5:0] <= din[21:16] (B path)\n    • Gating detail: out_to_small (status bit index 6) uses the top enable bit index 5; code also maps int_stat[4] with enable index 3 (shared with bit 3)\n  - Reset defaults: status clear; enables 0 (masked)\n\n- Live summaries and diagnostics\n  - RF 0x03 read returns:\n    • int_srca[15:0] (live OR of per-EP A/B for each EP; not sticky)\n    • int_srcb[8:0] (sticky RF events; read-to-clear)\n  - main_csr (0x00) provides live link state but is not an interrupt source\n\n- Event sources (non-exhaustive mapping)\n  - RF/link stickies (0x03): bus/reset/link transitions and parse errors (PID/CRC5/NSE/RXERR)\n  - Per-EP: buffer complete/release, timeouts (IN ACK, OUT data inactivity), DATA CRC16 error, PID sequence error, unexpected PID, HS OUT short (out_to_small)\n\n- Service and ordering guidelines\n  - Typical ISR flow: service per-EP INT first (read-to-clear), then read RF 0x03 to clear/record link-level events; this avoids losing edge-sensitive stickies while handling EP causes\n  - Ensure masks (0x02 and EPn enables) are programmed to route desired causes to inta_o/intb_o; all masks reset to 0",
        "Per-Endpoint Windows (CSR, INT, BUF0, BUF1)": "Per-Endpoint Windows (CSR, INT, BUF0, BUF1)\n- Addressing and layout\n  - Each endpoint n (0..15) occupies 4 word locations: base = 0x10 + 4*n (word addressing)\n    • +0: EPn_CSR (R/W) — Control/Status\n    • +1: EPn_INT (R/W) — Sticky interrupt/status (read-to-clear) and A/B enable masks\n    • +2: EPn_BUF0 (R/W) — Buffer 0 descriptor\n    • +3: EPn_BUF1 (R/W) — Buffer 1 descriptor\n  - Only build-enabled endpoints exist (e.g., EP0..EP3 here); others are reserved\n\n- EPn_CSR (R/W) — Endpoint Control/Status\n  - Core fields (conceptual):\n    • Direction/type: IN, OUT, or CTRL\n    • Endpoint number match (compared against token ep)\n    • DMA enable (when set and not CTRL)\n    • Max packet size (bytes)\n    • Policy bits: sml_ok (allow short OUT), lrg_ok (allow larger OUT)\n    • STALL/disable state control\n    • User toggles: uc_bsel[1:0] (buffer select), uc_dpd[1:0] (data PID base/toggle)\n    • Isoch microframe scheduling (tr_fr) when HS\n    • ots_stop: behavior on OUT short (latches status on out_to_small)\n  - Selection policy used by protocol engine:\n    • DMA EPs: always use BUF0\n    • CTRL EPs: IN uses BUF1; OUT/SETUP uses BUF0\n    • Non-DMA data: prefer uc_bsel[0]; auto-switch to other buffer if current is NA\n\n- EPn_INT (R/W) — Sticky Status + A/B Enables\n  - Sticky status causes (read-to-clear; SW may also write to clear):\n    • int_buf0_set, int_buf1_set (buffer events)\n    • int_to_set (timeout)\n    • int_crc16_set (DATA CRC16 error)\n    • int_seqerr_set (sequence/toggle error)\n    • int_upid_set (unexpected/illegal PID)\n    • out_to_small (HS OUT short-packet policy)\n  - Enable masks (drive per-EP inta/intb up to RF aggregator):\n    • A path: iena[5:0] <= din[29:24]\n    • B path: ienb[5:0] <= din[21:16]\n    • Mapping note: status bit[6] (out_to_small) uses top enable bit index 5; bit[4] shares enable index 3 with bit[3]\n  - Reset: status clear; enables = 0 (masked)\n\n- EPn_BUF0 / EPn_BUF1 (R/W) — Buffer Descriptors\n  - Format (32-bit):\n    • Address: bufX_adr = bufX[SSRAM_HADR+2:0] (byte address; low 3 bits = byte offset)\n    • Size/count: bufX[30:17]\n    • 0xFFFF_FFFF denotes NA (not available)\n  - Hardware write-back on transfer completion:\n    • IN: size decremented by sent bytes; address advanced by same amount; buffer_done when size reaches 0\n    • OUT (DMA): address/size advanced by MPS; for OUT-without-DMA: by actual received count (sizu_c)\n    • HS OUT short (out_to_small): write back sizu_c and preserve original address (no advance)\n  - Ping-pong operation: protocol engine toggles active buffer via uc_bsel when appropriate\n\n- Match gating and in-band updates\n  - All per-EP updates (CSR/BUF/INT, uc_bsel_set, uc_dpd_set, buf0_set, buf1_set, buf0_rl) are gated by ep_match (only the selected endpoint instance latches shared strobes)\n  - Two-phase update:\n    • UPDATE: descriptor write-back via idin (buf*_set) or buffer release (buf0_rl for DMA)\n    • UPDATE2: commit uc_bsel/uc_dpd via uc_*_set, using idin[3:0] to carry next_bsel/next_dpid\n\n- DMA interaction and flow control\n  - Per-EP DMA request/ack is handled in usbf_rf; counters track IN prefill and OUT space\n  - Convenience flags exported for matched EP: dma_in_buf_sz1 (≥1 MPS ready for IN), dma_out_buf_avail (≥1 MPS space for OUT)\n\n- Interrupt routing\n  - Per-EP INT A/B enables gate each endpoint’s causes into inta_o/intb_o via RF aggregation\n  - RF 0x03 provides a live summary (int_srca) of per-EP OR contributions (not sticky)\n\n- Reset defaults\n  - CSR/INT cleared; BUF0/BUF1 = 32'hFFFF_FFFF (NA) until programmed by software\n\n- Programming model (typical)\n  1) Write EPn_CSR: set direction/type, max packet, DMA enable (if used), policy bits; initialize uc_bsel/uc_dpd as needed\n  2) Program BUF0/BUF1 descriptors (address/size). For DMA EPs, at least BUF0 must be valid\n  3) Enable desired per-EP causes in EPn_INT (A/B masks) and RF-level masks at 0x02\n  4) On interrupts, read EPn_INT to clear sticky causes, then service RF 0x03 stickies as needed",
        "Vendor/PHY Access Registers": "Vendor/PHY Access Registers\n- Overview\n  - The core exposes a small UTMI vendor sideband access window and read-only PHY/link status. Software can:\n    • Read the PHY vendor status byte\n    • Drive the PHY vendor control nibble with an explicit load strobe\n    • Request device-initiated resume (remote wake)\n    • Read UTMI LineState and link-status flags (HS/attach/suspend)\n\n- 0x05 UTMI_VENDOR (R/W)\n  - Read (R): {24'b0, VStatus[7:0]}\n    • VStatus[7:0] is a latched copy of the UTMI PHY vendor/status bus; no side effects on read\n    • Sampling: VStatus is captured in phy_clk and made available in clk_i domain for software\n  - Write (W): VControl[3:0]\n    • Only bits [3:0] are used; bits [31:4] are ignored\n    • Each write also pulses VControl_Load so the PHY samples the new control nibble atomically\n    • Cross-domain: write generates a one-shot into phy_clk; do not rely on level-hold semantics\n  - Reset: VControl defaults to 0; VStatus read-back undefined until PHY drives it\n\n- 0x00 MAIN_CSR (R) — PHY/Link status snapshot\n  - bit[4:3] line_state[1:0]: UTMI LineState (as provided by the PHY)\n  - bit[2] usb_attached: debounced attach/VBUS status\n  - bit[1] mode_hs: 1=High-Speed, 0=Full-Speed\n  - bit[0] suspend: 1=in suspend\n  - Read-only; reflects live status produced by the UTMI/link FSM\n\n- 0x00 MAIN_CSR (W) — Remote wake (resume) request\n  - Write bit[5]=1 to request device-initiated resume (rf_resume_req one-shot)\n    • The UTMI/link FSM enforces USB timing (≥5 ms suspend before wake, ~1 ms K drive, settle)\n    • The request is a pulse (auto-clears); not a latched state\n\n- What is NOT software-controlled here\n  - UTMI control pins XcvSelect, TermSel, OpMode, SuspendM are driven by the internal link-state FSM; software can only observe their effect via MAIN_CSR (HS/attach/suspend, LineState)\n  - High-Speed Test Modes (SetFeature(TEST_MODE)) are not implemented in these registers\n\n- CDC, timing, and usage notes\n  - The 0x05 write always produces a VControl_Load pulse; perform a full write per change (no read-modify-write needed/meaningful)\n  - VStatus is level-latched for software reads; there is no read-to-clear behavior\n  - All registers are 32-bit word-aligned in clk_i (Wishbone) domain; vendor signals cross into phy_clk with one-shot strobes\n\n- Access summary\n  - 0x05 R: read PHY vendor status (8-bit)\n  - 0x05 W: drive PHY vendor control (4-bit) + implicit load strobe\n  - 0x00 R: read link snapshot (suspend/HS/attached/LineState)\n  - 0x00 W bit[5]: pulse remote-wake request",
        "Resume/Wakeup Control": "Resume/Wakeup Control\n- What software can do\n  - Request device-initiated resume (remote wake) by writing 1 to MAIN_CSR bit[5] (address 0x00). This generates rf_resume_req (one-shot) into the link FSM.\n  - Observe suspend state and link status via MAIN_CSR (0x00): suspend[0], mode_hs[1], usb_attached[2], line_state[4:3].\n  - Track suspend transitions in INT_SOURCES (0x03): suspend_start[3] and suspend_end[4] (read-to-clear).\n\n- External/system control\n  - resume_req_i top-level input allows a system-side (non-Wishbone) remote-wake request. The top-level latches a unified resume_req_r and feeds it to the UTMI link FSM.\n\n- Link/FSM behavior (UTMI-driven)\n  - Device-initiated resume sequence (while suspended):\n    • Enforce minimum suspend duration (~5 ms, T1_gt_5_0_mS)\n    • Enter RESUME_REQUEST → RESUME_SIG: drive K on the bus for ~1 ms\n    • RESUME: wait for SE0, restore normal OpMode/xceiver selection (HS/FS)\n    • RESUME_WAIT: settle for ~100 µs, then NORMAL\n  - Host-initiated resume: detected as K while in SUSPEND; FSM transitions to RESUME and completes the same restore/settle path.\n  - During resume/chirp drive, DataOut is neutralized (00h) and TxValid is gated to ensure proper UTMI handshakes.\n\n- Latching and clearing of requests\n  - rf_resume_req (from 0x00 write) is converted to a one-shot in clk_i, latched at top level (resume_req_r), then presented in phy_clk to the link FSM.\n  - The request auto-clears when the FSM emits suspend_clr (on leaving SUSPEND/finishing resume).\n\n- Timing guarantees (implemented in hardware FSM)\n  - Minimum suspend before function-initiated resume: ~5 ms\n  - Resume (K) drive duration: ~1 ms\n  - Post-resume settle: ~100 µs\n\n- Status and interrupts for firmware\n  - MAIN_CSR.suspend reflects live suspend state (also exported as susp_o at clk_i).\n  - INT_SOURCES bits:\n    • [3] suspend_start (rising edge of suspend)\n    • [4] suspend_end (falling edge of suspend)\n  - usb_reset [8] indicates bus reset (clears suspend and reinitializes link).\n\n- Recommended software flow for remote wake\n  1) Ensure the device is in suspend (MAIN_CSR.suspend=1) and that policy (e.g., standard USB RemoteWakeup feature) permits wake.\n  2) Write MAIN_CSR bit[5]=1 to pulse rf_resume_req.\n  3) Optionally poll MAIN_CSR.suspend until 0 and/or read INT_SOURCES to observe suspend_end.\n\n- Notes/limits\n  - The core does not enforce the USB RemoteWakeup feature enable; firmware must gate use per Chapter 9 policy.\n  - UTMI Test Modes are not exposed via these controls.\n  - All controls are word-aligned in the Wishbone (clk_i) domain; cross-domain delivery uses one-shot strobes to phy_clk.",
        "Memory Access Window and Alignment": "Memory Access Window and Alignment\n- Region selection and addressing\n  - Wishbone address bit wb_addr_i[17] selects space:\n    • 0: Register File (RF)\n    • 1: Memory Array (MA) — external packet SRAM window\n  - MA effective word address = wb_addr_i[SSRAM_HADR+2:2]\n  - Port width: 32-bit; accesses are word-aligned (no byte enables/SEL)\n  - With USBF_TEST_IMPL (SSRAM_HADR=14): memory size = 4 × 2^(SSRAM_HADR+1) = 128 KiB\n\n- Software access semantics (MA)\n  - Single-beat transfers only; one outstanding request at a time\n  - ACK timing: wb_ack_o asserted when mem arbiter returns ma_ack; no pipelining\n  - Arbiter priority: protocol/DMA master (M) has absolute priority; software (W) sees service only when M is idle\n  - W-side pacing: when served continuously (M idle), W ACK pulses every other phy_clk; throughput ≤ 1 transfer per 2 phy_clk cycles\n  - Read data (sram_din) is broadcast to both masters; software must sample only on ACK\n  - sram_re is tied high; memory enables/timing must be met externally/by device\n\n- Alignment rules and buffer addressing (DMA path)\n  - Descriptor address fields (BUF0/BUF1): bufX[SSRAM_HADR+2:0] carry a byte address\n    • Word part: adr_cw = adr[SSRAM_HADR+2:2]\n    • Byte offset: adr_cb = adr[2:0]\n  - Unaligned starts supported by hardware:\n    • RX: first word is read then updated (read-modify-write) to place initial bytes at adr_cb; final partial word is flushed at packet end\n    • TX: two-word ping‑pong prefetch; byte mux selects lanes based on adrb_next[2:0]\n  - Ring/wrap support when dma_en set: address wraps at last_buf_adr = adr + buf_size\n\n- Software constraints and recommendations\n  - Software MA accesses must be 32-bit and word-aligned; sub‑word or byte writes are not supported\n  - For unaligned packet data, use the endpoint DMA engine; it handles RMW and byte steering internally\n  - Expect variable latency due to M‑side priority; avoid large SW bursts while USB transfers are active\n\n- CDC and robustness notes\n  - MA request/ACK is sequenced in phy_clk; wb_ack_o is synchronized back to wb_clk as a single-cycle pulse\n  - Best used when wb_clk == phy_clk or properly timing-closed; otherwise observe CDC caveats\n\n- Summary\n  - Memory array is a flat, word-aligned 32-bit window selected by wb_addr_i[17]=1; size set by SSRAM_HADR\n  - Hardware DMA supports arbitrary byte alignment via RMW (RX) and byte-lane muxing (TX); software accesses remain word-aligned only",
        "Reset Values and Access Types": "Reset Values and Access Types\n- Global RF window (wb_addr_i[17]=0)\n  - 0x00 MAIN_CSR / CTRL\n    • Read: RO status {line_state[4:3], usb_attached[2], mode_hs[1], suspend[0]}; resets to 0\n    • Write: WO one-shot at bit[5] (rf_resume_req pulse); other bits ignored; resets to 0\n  - 0x01 FUNC_ADDR\n    • R/W (7-bit device address); reset = 0\n  - 0x02 INT_MASKS (A/B)\n    • R/W {intb_msk[8:0], inta_msk[8:0]}; reset = 0 (all masked)\n  - 0x03 INT_SOURCES\n    • Read: {int_srcb[8:0] sticky RF events, int_srca[15:0] live per‑EP OR}; int_srcb is read‑to‑clear; reset = 0\n  - 0x04 FRM_NAT\n    • Read-only; reset = 0\n  - 0x05 UTMI_VENDOR\n    • Read: RO {24'b0, VStatus[7:0]} (latched PHY vendor/status); reset: value depends on PHY, internal latch resets 0\n    • Write: WO lower 4 bits VControl[3:0]; write also generates VControl_Load one-shot; VControl resets = 0\n\n- Per-endpoint windows (EPn at 0x10 + 4*n)\n  - +0 EPn_CSR\n    • R/W control/status; resets to 0 (direction/type, DMA enable, MPS, policy bits, uc_bsel/uc_dpd all cleared)\n  - +1 EPn_INT (hybrid)\n    • Read: RO sticky status bits (read‑to‑clear); reset = 0\n      – Bits include: to_set, crc16_err, upid, buf0_set, buf1_set, seqerr, out_to_small\n    • Write: programs enable masks only\n      – iena[5:0] (A path) <= din[29:24], ienb[5:0] (B path) <= din[21:16]; reset = 0 (all masked)\n    • Note: status bit[6] (out_to_small) uses enable index 5; int_stat[4] shares enable index 3 with bit[3]\n  - +2 EPn_BUF0\n    • R/W buffer descriptor; reset = 32'hFFFF_FFFF (NA sentinel). buf0_orig also initializes to 0xFFFF_FFFF\n  - +3 EPn_BUF1\n    • R/W buffer descriptor; reset = 32'hFFFF_FFFF (NA sentinel)\n\n- Access and side-effects summary\n  - Read-to-clear: RF int_srcb (0x03[8:0]); EPn_INT sticky status (EP base+1 read)\n  - One-shot writes: MAIN_CSR bit[5] (rf_resume_req); UTMI_VENDOR write (VControl_Load pulse)\n  - Read-only: MAIN_CSR status bits; FRM_NAT; UTMI_VENDOR readback; int_srca (live per‑EP OR)\n  - Read/write: FUNC_ADDR; INT_MASKS; EPn_CSR; EPn_BUF0/BUF1; EPn_INT enable masks via write\n\n- Reset behavior and domains\n  - Resets are synchronous (unless USBF_ASYNC_RESET defined)\n  - Global RF regs and sticky flags reset to 0; EP buffer descriptors reset to 0xFFFF_FFFF; EP interrupt enables reset to 0; CSR/controls reset to 0\n  - VStatus latch resets 0 (true value depends on PHY after link-up)"
    },
    "Interface Specifications": {
        "Clock and Reset Interfaces": "Clock and Reset Interfaces\n- Clock domains and ports\n  - phy_clk_pad_i (input): UTMI/PHY domain. Drives usbf_utmi_if, usbf_pl (protocol/DMA), usbf_mem_arb (SRAM arbiter M/W core), and the RF \"core view\" side.\n  - clk_i (input): Wishbone/bus domain. Drives usbf_wb (WB front‑end), RF \"bus view\" (register file), and top‑level status (e.g., susp_o).\n  - Internal wb_clk in usbf_wb mirrors clk_i for Wishbone‑facing registers.\n\n- Reset ports and distribution\n  - rst_i (input): Global reset fan‑out. As coded, resets are synchronous in both clk_i and phy_clk_pad_i domains (USBF_ASYNC_RESET optional to enable selected async resets).\n  - phy_rst_pad_o (output): PHY reset pad, driven directly from rst_i (same assertion timing/polarity as rst_i).\n\n- Reset behavior (high‑level)\n  - Synchronous reset of all major blocks when rst_i asserted.\n  - UTMI/link FSM (usbf_utmi_if/usbf_utmi_ls) enters POR state; FS path selected, TermSel enabled, mode_hs=0 until negotiated.\n  - Register file (usbf_rf) clears global regs/stickies; per‑EP BUF0/BUF1 reset to 0xFFFF_FFFF.\n  - Wishbone front‑end FSM resets synchronously in phy_clk; ACK path in wb_clk remains clean via synchronizer.\n\n- Cross‑domain crossings (CDC) and one‑shots\n  - Wishbone request/ack: usbf_wb samples new WB requests in phy_clk and returns a one‑cycle wb_ack_o pulse in clk_i via a small 3‑FF edge detector.\n  - RF control pulses (clk_i → phy_clk):\n    • rf_resume_req (from MAIN_CSR write) is converted to a one‑shot in clk_i and consumed in phy_clk by the link FSM.\n    • UTMI vendor control write (0x05) produces a VControl_Load one‑shot into phy_clk.\n  - DMA handshake (clk ↔ wclk) inside usbf_rf: per‑EP dma_req/dma_ack bridged with request/ack flip‑flop handshake and hold logic.\n\n- Domain ownership of key outputs\n  - UTMI pins (DataOut, TxValid, XcvSelect, TermSel, SuspendM, OpMode) driven in phy_clk domain by usbf_utmi_if.\n  - SRAM interface (sram_adr_o, sram_we_o, sram_data_o) multiplexed in phy_clk by usbf_mem_arb.\n  - Wishbone wb_ack_o generated as a single clk_i‑cycle pulse; rf register accesses occur in clk_i; memory accesses are sequenced in phy_clk and acknowledged back to clk_i.\n  - Interrupts inta_o/intb_o produced in the RF bus view (clk_i) from per‑EP and RF‑level sources.\n\n- Optional asynchronous reset usage\n  - If USBF_ASYNC_RESET is defined, selected flops in UTMI Rx/Tx valid/active/error paths (and some FSMs) include async reset; otherwise all resets are synchronous.\n\n- Integration guidance\n  - Prefer clk_i and phy_clk_pad_i to be same or frequency/phase‑related; if independent, respect CDC constraints (requests sampled in phy_clk; ACK edge synchronized back to clk_i).\n  - Hold rst_i long enough to guarantee both domains observe reset; phy_rst_pad_o follows rst_i for PHY sequencing.",
        "UTMI PHY Data and Control Interface": "UTMI PHY Data and Control Interface\n- Interface signals (8-bit UTMI)\n  - Data path:\n    • DataIn[7:0] (from PHY) → registered to rx_data in phy_clk\n    • DataOut[7:0] (to PHY) driven from tx_data with SOP pre-load and special-mode neutralization\n    • TxValid (to PHY) with hold-until-ready logic and last-byte guarantee\n    • TxReady (from PHY) mirrored to tx_ready\n    • RxValid/RxActive/RxError (from PHY) registered to rx_valid/rx_active/rx_err\n  - Line and mode control (to PHY): XcvSelect, TermSel, SuspendM, OpMode[1:0]\n  - Line status and attach (from PHY): LineState[1:0], usb_vbus\n  - Vendor sideband: VStatus[7:0] (readback), VControl[3:0] + VControl_Load (write strobe)\n\n- Clock/reset domain\n  - All UTMI data/control handled in phy_clk_pad_i domain. Resets are synchronous by default; selected flops may support async reset if USBF_ASYNC_RESET is defined.\n\n- Receive path (PHY → core)\n  - RxValid, RxActive, RxError are captured and registered every phy_clk; DataIn is registered (no explicit reset). Provides clean one-cycle qualified rx_* signals into the protocol layer.\n\n- Transmit path (core → PHY)\n  - DataOut behavior:\n    • If (TxReady || tx_first) then DataOut <= tx_data to ensure first byte is present at SOP (tx_first pre-load)\n    • Else if (drive_k) DataOut <= 8'h00 during resume/chirp special modes (neutral value)\n  - TxValid generation:\n    • Asserts on tx_valid (data byte request), drive_k (special signaling), or tx_valid_last (final beat guarantee)\n    • Holds high until TxReady, except the cycle after drive_k (bounded pulse via drive_k_r)\n    • Resets low; ensures robust UTMI TxValid/TxReady handshakes at SOP and last byte\n\n- Link state and control (managed by usbf_utmi_ls)\n  - Decodes LineState into J/K/SE0/SE1 with 2-cycle \"long\" qualification to filter glitches\n  - State machine sequences attach (debounced ~100 ms), reset detect, suspend entry/exit, device-initiated resume, and HS negotiation via chirps\n  - Resume (remote wake): after T2_wakeup (~5 ms), drive K for ~1 ms (RESUME_SIG), then wait for SE0 and settle ~100 µs before NORMAL; during drive_k, DataOut forced to 00h and TxValid pulsed appropriately\n  - High-speed negotiation: device K, count alternating host K/J chirps (6 required) → select HS else fall back to FS\n\n- UTMI control pin driving per state\n  - XcvSelect: 1=FS receiver, 0=HS receiver\n  - TermSel: FS termination enable (1=on)\n  - OpMode: 2'b00 Normal; 2'b10 Disable bit-stuff/NRZI during reset/resume/chirp\n  - SuspendM: asserted when not suspended (and per specific line-state conditions); verify polarity vs PHY (UTMI defines high = not suspended)\n\n- Status exports to core\n  - mode_hs (HS=1), usb_reset (bus reset detected), usb_suspend (in suspend), usb_attached (attach debounced), suspend_clr (one-shot on suspend exit)\n\n- Remote wakeup and vendor sideband\n  - Remote wake: software writes MAIN_CSR bit[5] → rf_resume_req one-shot (clk_i) → synchronized to phy_clk as resume_req_r; usbf_utmi_if drives the UTMI K-resume sequence\n  - Vendor sideband: software writes UTMI_VENDOR lower 4 bits → VControl[3:0]; write auto-pulses VControl_Load; VStatus[7:0] latched for readback\n\n- Protocol/data conventions\n  - Byte order is LSB-first on UTMI; CRC generation/checking and PID handling in protocol layer follow USB 2.0 conventions\n\n- Notes/limits\n  - UTMI Test Modes (SetFeature TEST_MODE) are not exposed here\n  - SuspendM polarity and any PHY-specific nuances should be verified against the attached PHY",
        "External SSRAM Interface": "External SSRAM Interface\n- Physical port (single-port, 32-bit)\n  - Address: sram_adr_o[SSRAM_HADR:0] (word address in phy_clk domain)\n  - Data: sram_data_o[31:0] (write), sram_data_i[31:0] (read)\n  - Controls: sram_we_o (write enable, 1=write), sram_re_o (read enable, tied high)\n  - Clock domain: all signals driven/used in phy_clk_pad_i\n  - Parameter: SSRAM_HADR sets address width (default/test build 14)\n\n- Capacity and addressing\n  - Word-addressed interface (32-bit words); no byte enables/SEL\n  - Total size (bytes) = 4 × 2^(SSRAM_HADR+1); with SSRAM_HADR=14 → 128 KiB\n  - Core “M” master (protocol/DMA) and Wishbone “W” master share this single port via usbf_mem_arb\n\n- Arbiter and ownership (usbf_mem_arb)\n  - Fixed priority: M (protocol/DMA) has absolute priority; W (software) is served only when M is idle\n  - Selection: wsel = (wreq | wack) & !mreq; read data (sram_data_i) is broadcast to both masters (sample only on your ACK)\n  - Handshakes:\n    • M side: mack = mreq (combinational, zero-wait view)\n    • W side: wack = 1-cycle pulse when served; if wreq held and M idle, wack pulses every other phy_clk (≤ 1 transfer/2 cycles)\n  - sram_re_o is tied high; external memory must satisfy read-enable/CS timing\n\n- Software access window (via Wishbone)\n  - Region select: wb_addr_i[17] = 1 selects Memory Array (SSRAM window)\n  - Effective word address (software): wb_addr_i[SSRAM_HADR+2:2]\n  - Access type: 32-bit, word-aligned, single-beat, one outstanding at a time; ACK returned on mem arbiter service (no bursts/pipelining)\n\n- DMA/Protocol access (core “M” side)\n  - IDMA presents madr[SSRAM_HADR:0] (word address), mreq, mwe and uses mdin/mdout for data\n  - Alignment support:\n    • RX: read–modify–write for unaligned first word; flush final partial word\n    • TX: two-word ping-pong prefetch; byte-steered output\n  - Ring/wrap: when dma_en set, address wraps at adr + buf_size\n\n- Timing/CDC\n  - Entire SSRAM path is in phy_clk; W requests are sampled in phy_clk; W ACK is synchronized back to clk_i (wb_clk) as a 1-cycle pulse\n  - Best used with clk_i == phy_clk or with proper CDC/timing closure\n\n- Integration notes\n  - Provide external chip-select/output-enable as required by your SSRAM; sram_re_o is constantly asserted high by the core\n  - Ensure memory meets single-cycle read visibility at the arbiter boundary (M sees zero-wait mack); software side is paced by wack (every other phy_clk when granted)\n  - Bus width must be 32-bit; no byte-write strobes are generated",
        "DMA Handshake Interface": "DMA Handshake Interface\n- Ports and clocking\n  - dma_req_o[15:0] (output, clk_i domain): one bit per endpoint (bit n → EPn) requesting external DMA service.\n  - dma_ack_i[15:0] (input, clk_i domain): one‑cycle acknowledge pulses from the external DMA engine; one pulse == one 32‑bit word serviced for the corresponding endpoint.\n  - Internal CDC: a robust 2‑domain handshake is used inside usbf_rf to reflect dma_ack_i into the core (phy_clk) domain; external DMA should present dma_ack_i synchronous to clk_i.\n\n- Transfer granularity and meaning\n  - Granularity: 32‑bit words (no byte strobes). All DMA counters/thresholds operate in words.\n  - Direction semantics per endpoint:\n    • OUT endpoints (host→device): dma_req_o[n] asserts when words remain to be drained from the endpoint buffer (dma_out_cnt != 0). Each dma_ack_i[n] pulse decrements the outstanding word count by 1.\n    • IN endpoints (device→host): dma_req_o[n] asserts while the prefill level is below the configured capacity (dma_in_cnt < buf0_orig[30:19]). Each dma_ack_i[n] pulse increments the filled word count by 1.\n\n- Request generation, hold, and deassertion (inside usbf_rf)\n  - A request is raised when the per‑EP condition is true and no previous request is in flight; it is held across bursts per hold logic:\n    • OUT hold: keeps request asserted while at least one word beyond the last three remains (|dma_out_cnt[11:2]).\n    • IN hold: keeps request asserted until within three words of full capacity and capacity ≥ 8 words (dma_req_in_hold && dma_req_in_hold2).\n  - Deassertion: request clears after dma_ack_i arrives and hold condition allows it; otherwise it stays asserted to sustain bursting.\n\n- Packet size coupling\n  - Max‑packet size P (words) = {3'b000, CSR[10:2]}; used to step counters on packet boundaries.\n  - On buffer (re)programming events (buf0_set/buf0_rl aligned with an internal ack), OUT outstanding increases by P; IN available decreases by P. Short‑packet and special cases are handled in the protocol engine and reflected into counters/write‑backs.\n\n- Functional expectations for the external DMA engine\n  - Monitor dma_req_o[n] and return one‑cycle dma_ack_i[n] pulses for each 32‑bit word serviced. Acks may be bursty and need not be contiguous, but must not exceed one pulse per clk_i cycle per endpoint.\n  - Service endpoints independently; multiple bits of dma_req_o may be active simultaneously.\n  - Do not pulse dma_ack_i[n] when dma_req_o[n] is deasserted.\n\n- Reset/initialization behavior\n  - On reset, per‑EP DMA counters clear; dma_req_o is inactive until endpoints are configured (CSR, BUF descriptors) and protocol events allocate work.\n\n- Relationship to internal memory path\n  - This handshake advertises/consumes per‑endpoint word‑level service and is independent of the internal SSRAM arbiter (usbf_mem_arb) used by the USB datapath. Actual data movement/storage is managed by the system using the shared SSRAM window; the core’s req/ack only tracks per‑EP word flow.\n\n- Timing/CDC notes\n  - dma_req_o is generated in clk_i; dma_ack_i must be synchronous to clk_i. The core safely transfers ack events into phy_clk for counter updates.\n  - Each ack corresponds to exactly one 32‑bit word; no multi‑word ‘count’ acks are supported.",
        "Interrupt Outputs": "Interrupt Outputs\n- Signals and clock domain\n  - inta_o, intb_o (active-high outputs, clk_i domain)\n  - Reset default: deasserted (0)\n\n- Composition and masking\n  - Outputs are ORs of two classes of sources:\n    • Endpoint-level: OR of per-endpoint masked interrupt outputs (ep0..ep15) after each EP’s local mask/enable.\n    • RF-level (global/link) sticky events: masked by RF A/B masks.\n  - Equations (inside usbf_rf):\n    • inta_o = inta_ep | inta_rf\n    • intb_o = intb_ep | intb_rf\n  - RF masks at 0x02: inta_msk[8:0], intb_msk[8:0]\n  - Endpoint masks (per EP, adr +1): iena[5:0] for A, ienb[5:0] for B\n\n- RF-level (global/link) interrupt sources (sticky, read-to-clear at 0x03)\n  - int_srcb[8:0] bits:\n    • [8] usb_reset\n    • [7] rx_err_r (UTMI RxError)\n    • [6] deattach (usb_attached falling)\n    • [5] attach (usb_attached rising)\n    • [4] suspend_end (suspend falling)\n    • [3] suspend_start (suspend rising)\n    • [2] nse_err_r (token not for this function/EP)\n    • [1] pid_cs_err_r (PID complement error)\n    • [0] crc5_err_r (token CRC5 error)\n  - Reading 0x03 clears these sticky bits; masking is applied before aggregation to inta_o/intb_o.\n  - int_srca[15:0] provides a live OR of per-EP A/B (software readback, not sticky)\n\n- Per-endpoint interrupt sources (sticky, read-to-clear in each EP’s INT register)\n  - Typical causes (from protocol layer):\n    • buf0_set, buf1_set (buffer event)\n    • buf0_rl (release/consumed)\n    • int_crc16_set (DATA CRC16 error)\n    • int_to_set (timeout)\n    • int_upid_set (unexpected PID)\n    • int_seqerr_set (sequence/toggle error)\n    • out_to_small (HS OUT short-packet policy)\n  - Each EP gates its sticky bits through local enables:\n    • A-path enables: iena[5:0] → contribute to inta_ep\n    • B-path enables: ienb[5:0] → contribute to intb_ep\n\n- Software interface summary\n  - 0x02 (RF masks): set inta_msk/intb_msk to route RF-level events to A/B\n  - 0x03 (RF sources): read to fetch {int_srcb, int_srca}; reading clears RF sticky (int_srcb)\n  - EPn INT (base 0x10+4*n + 1): read returns EP sticky; read clears; write can also clear; iena/ienb fields control EP → A/B routing\n\n- Timing/behavior\n  - inta_o/intb_o assert synchronously to clk_i when any masked source is set, and deassert when corresponding sticky status is cleared and/or masked off.\n  - No dedicated interrupt status latches at top-level beyond the RF/EP sticky registers; software uses those for cause identification.\n\n- Usage guidance\n  - Route inta_o and intb_o to separate CPU/SoC IRQ lines to distinguish endpoint/data events from link/global events as desired via masks.\n  - Poll/clear RF (0x03) and per-EP INT windows to service and deassert interrupts.",
        "Power and Status Signals": "Power and Status Signals\n- External power/link pins\n  - usb_vbus (from UTMI PHY): used by link-state logic to gate POR/attach behavior and declare usb_attached after debounce (~100 ms).\n  - LineState[1:0] (from UTMI PHY): captured and exposed to software in MAIN_CSR[4:3].\n\n- Resets and clocks\n  - rst_i (in): synchronous reset (USBF_ASYNC_RESET optional). Drives rst internally and phy_rst_pad_o.\n  - phy_rst_pad_o (out): forwarded reset toward PHY (follows rst_i).\n  - Clock domains: phy_clk_pad_i for UTMI/protocol/memory; clk_i for Wishbone/RF bus view and top-level status sampling.\n\n- Suspend/resume controls and indicators\n  - susp_o (out, clk_i): registered copy of usb_suspend (link in suspend). Deasserts on resume/reset.\n  - SuspendM (to UTMI): asserted when not suspended (UTMI polarity: high = not suspended).\n  - OpMode[1:0] (to UTMI): 2'b00 normal; 2'b10 during reset/resume/chirp (disable bit-stuff/NRZI) per link state.\n  - resume_req_i (in, clk_i): software-driven remote wake request. Latched to resume_req_r; cleared by suspend_clr on suspend exit. Causes link FSM to drive K for ~1 ms (device resume), then settle.\n  - suspend_clr (internal, from link FSM): one-shot pulse on suspend exit; used to clear resume_req_r.\n\n- Link status (internal generation, software-visible via RF)\n  - mode_hs: 1=High-Speed, 0=Full-Speed (set after HS negotiation). Readable in MAIN_CSR[1].\n  - usb_reset: asserted during bus reset detection (SE0 window). Sticky RF event bit INT_SOURCES[8] (read-to-clear).\n  - usb_suspend: link in suspend (idle long). Readable in MAIN_CSR[0]; also generates RF sticky events (start/end) at INT_SOURCES[3]/[4].\n  - usb_attached: debounced attach based on usb_vbus; MAIN_CSR[2]. RF sticky attach/deattach at INT_SOURCES[5]/[6].\n  - LineState snapshot: MAIN_CSR[4:3] mirrors UTMI LineState[1:0].\n\n- Software-visible status/control registers (RF space, wb_addr_i[17]=0)\n  - 0x00 MAIN_CSR (R): {line_state[1:0], usb_attached, mode_hs, suspend}. (W): write '1' to bit[5] generates a remote-wake (rf_resume_req) one-shot.\n  - 0x03 INT_SOURCES (R, read-to-clear sticky RF events):\n    • [8] usb_reset, [7] rx_err_r, [6] deattach, [5] attach, [4] suspend_end, [3] suspend_start, [2] nse_err_r, [1] pid_cs_err_r, [0] crc5_err_r.\n  - 0x04 FRM_NAT (R): frame/microframe timing snapshot (diagnostic status).\n  - 0x05 UTMI_VENDOR (R/W): read VStatus[7:0]; write VControl[3:0] with implicit VControl_Load strobe.\n\n- UTMI transceiver selection and termination (link-driven)\n  - XcvSelect: selects HS vs FS receiver path (0=HS, 1=FS per code usage).\n  - TermSel: FS termination enable (1=on). Driven per state (attach, suspend, reset, HS chirp/entry).\n\n- Behavioral summary\n  - Attach: after usb_vbus stable (~100 ms) → usb_attached=1; MAIN_CSR[2] reflects state.\n  - Suspend: long idle triggers usb_suspend; susp_o asserts; SuspendM deasserts (enter suspend). Exit suspend via host K or device remote-wake; suspend_clr pulses, susp_o deasserts.\n  - Remote wake: write MAIN_CSR[5] (rf_resume_req) → link drives K ~1 ms, then settle ~100 µs; clears resume_req latch on suspend exit.\n  - Reset: SE0 qualified window asserts usb_reset; UTMI OpMode switches to special mode during reset; RF sticky INT_SOURCES[8] set.\n  - Speed: HS negotiated via chirp sequence (six K/J toggles) → mode_hs=1; otherwise remain FS.\n\n- CDC and reporting\n  - LineState_r and VStatus_r are captured in phy_clk and reported to software via MAIN_CSR and UTMI_VENDOR; suspend status is bridged to clk_i as susp_o.\n\n- Defaults on reset\n  - MAIN_CSR status fields clear; function address=0; RF masks=0; vendor control=0; inta_o/intb_o deasserted.",
        "Timing and Handshake Requirements": "Timing and Handshake Requirements\n- UTMI transmit/receive handshakes (phy_clk domain)\n  - TxValid/TxReady protocol:\n    • TxValid asserts when tx_valid, drive_k, or tx_valid_last is set, and holds until TxReady=1.\n    • Hold is disabled for one cycle after drive_k (bounded pulse in special UTMI modes).\n  - Start-of-packet data presence:\n    • tx_first pre-load ensures DataOut is valid at SOP even before TxReady.\n  - Last-byte visibility:\n    • tx_valid_last guarantees the final beat is observed by the PHY even if tx_valid drops early.\n  - Special signaling:\n    • During resume/chirp (drive_k=1), DataOut is forced to 0x00 and TxValid is pulsed per above.\n  - Receive timing:\n    • RxValid/RxActive/RxError and DataIn are registered each phy_clk; downstream packet decoder aligns data_valid with a two-byte pipeline so only payload bytes are marked valid.\n\n- Link timing windows (managed by UTMI link FSM in phy_clk)\n  - Debounce attach: ~100 ms stable VBUS/attach before usb_attached=1.\n  - Reset detect: qualified SE0 window (per T1 thresholds) while not idle_long.\n  - Suspend entry: long idle (e.g., T1_gt_3.0 ms) → usb_suspend=1.\n  - Device remote wake:\n    • Allowed only after suspend has lasted ≥ ~5 ms (T2_wakeup).\n    • Drive K ~1 ms (T2_gt_1.0 ms), then wait for SE0 and settle ~100 µs (T2_gt_100 µs) before NORMAL.\n  - HS negotiation (chirp):\n    • Device chirp K ~1.2 ms (T2_gt_1.2 ms) then count 6 alternating host K/J chirps to enter HS; otherwise fallback to FS.\n  - State qualification:\n    • LineState long qualifiers (J/K/SE0) require two consecutive samples; idle detection is J (FS) or SE0 (HS) with two-sample hysteresis.\n  - Timer base:\n    • Internal timing built from ~250 ns ticks aggregated into ~2.5 µs, 100 µs, 0.5 ms, 1.0 ms, 1.2 ms, 3.0/3.125/5/30/50/100 ms windows.\n\n- Protocol engine handshakes and timeouts (phy_clk domain)\n  - IN path (device→host):\n    • After sending DATA PID+payload, wait for host ACK; timeout thresholds differ for HS vs FS (defined by macros; typical HS≈22 cycles, FS≈36 cycles of clk).\n    • On ACK, timeout, or error, descriptor updates and int_* pulses occur atomically.\n  - OUT/SETUP path (host→device):\n    • Activity watchdog (tx_data_to) while expecting data; cleared by rx_active; HS/FS thresholds via macros.\n    • Handshake selection (ACK/NACK/STALL/NYET) occurs at end-of-packet with one-cycle TOKEN emission.\n  - Packet assembler (TX):\n    • Handshake packets are single-byte with tx_valid_last asserted; data packets drive rd_next only when (tx_ready && tx_valid_r).\n    • Deassert send_data exactly when the last payload byte is accepted (tx_ready=1) to transition to CRC emission; last holds until CRC2 is accepted.\n\n- DMA handshake timing (clk_i domain externally, CDC into phy_clk)\n  - Requests (dma_req_o[n]) assert when service is needed; external engine must return one-cycle dma_ack_i[n] pulses:\n    • Exactly one 32-bit word per ack; do not pulse ack when req=0.\n    • Per-endpoint rate: ≤ 1 ack per clk_i per EP.\n  - Burst sustain/hold:\n    • OUT: request held while at least one word beyond the last three remains (|dma_out_cnt[11:2]).\n    • IN: request held until within three words of full and capacity ≥ 8 words.\n  - CDC safety:\n    • Ack pulses in clk_i are synchronized into phy_clk; deassertion of requests respects hold conditions to avoid dropped words.\n\n- External SSRAM and arbiter pacing (phy_clk domain)\n  - Core (M) master: mack=mreq (combinational, zero-wait view) — upstream logic must meet memory timing; no wait-states added.\n  - Wishbone (W) master: wack pulses one phy_clk every other cycle when granted (≤ 1 transfer / 2 phy_clk); preempted immediately if M asserts mreq.\n  - Read data is always visible; masters must sample only when their ack is asserted.\n  - sram_re_o is tied high; external memory must satisfy OE/CS timing for continuous-read operation.\n\n- Wishbone bus handshake (clk_i and phy_clk domains)\n  - Single outstanding transaction; new requests sampled only in IDLE.\n  - ACK generation: one-cycle wb_ack_o pulse in clk_i per completed access (immediate for RF, on ma_ack for MA), produced via a 3-FF edge detector.\n  - Dead-time: W1/W2 spacing states avoid back-to-back ACK hazards.\n  - CDC requirement: Best used with wb_clk == phy_clk; otherwise ensure timing closure since request sampling crosses domains without a 2-FF synchronizer.\n\n- Reset and CDC requirements\n  - Resets are synchronous by default; optional async reset via USBF_ASYNC_RESET on select flops.\n  - All UTMI/protocol/memory timing is in phy_clk; software/RF/interrupt/DMA acks originate or are observed in clk_i and are synchronized across domains with explicit one-shots or edge detectors.\n\n- Compliance/assumptions\n  - Numerical thresholds for timeouts and link windows are parameterized by macros; integrate with a UTMI PHY that respects TxValid/TxReady and line-control timing.\n  - SETUP/control-pipe edge cases and HS Test Modes are not enforced in RTL and may affect strict USB 2.0 certification; system firmware should account for this in end-to-end timing policies.",
        "Signal Polarity and Conventions": "Signal Polarity and Conventions\n- General\n  - Unless noted, control signals are active-high and synchronous to their stated clock domain.\n  - Pulses/one-shots (e.g., wb_ack_o, wack, rf_resume_req, uc_*_set, buf*_set) are active-high, single-cycle in their respective domains.\n  - USB byte/bit ordering follows USB LSB-first conventions (PIDs as {~pid, pid}; DATA CRC16 sent low byte first; CRC engines expect LSB-first input).\n\n- Resets\n  - Top-level: resets are synchronous by default (USBF_ASYNC_RESET enables async in some flops).\n  - usbf_wb local FSM uses an active-low reset input (rst=0 asserts reset); other blocks use active-high synchronous reset unless otherwise defined.\n  - phy_rst_pad_o mirrors the core reset toward the PHY (same polarity as driven by top-level logic).\n\n- UTMI interface (active-high unless stated)\n  - TxValid (out): 1 indicates valid transmit byte; held until TxReady=1 (except one cycle after drive_k).\n  - TxReady (in): 1 from PHY acknowledges byte acceptance.\n  - RxValid/RxActive/RxError (in): 1 indicates valid data byte, packet active, and receive error, respectively.\n  - DataIn/DataOut[7:0]: 8-bit data; LSB-first on the wire.\n  - LineState[1:0] (in): encoded UTMI line state (J/K/SE0/SE1), sampled active-high.\n  - XcvSelect (out): 1 = FS xceiver, 0 = HS xceiver.\n  - TermSel (out): 1 enables FS termination, 0 disables.\n  - SuspendM (out): active-high \"not suspended\" (1 keeps PHY out of suspend).\n  - OpMode[1:0] (out): 2'b00 = normal; 2'b10 = disable bit-stuff/NRZI (used during reset/resume/chirp).\n  - drive_k (internal from link FSM): active-high requests driving K on the bus during resume/chirp; DataOut forced to 8'h00 while active.\n\n- Wishbone (clk_i domain; classic B3)\n  - Inputs: wb_stb_i, wb_cyc_i, wb_we_i are active-high.\n  - wb_ack_o: active-high, single clk_i cycle per completed transfer.\n  - Word-aligned addressing; wb_addr_i[17]=0 selects RF, 1 selects Memory Array.\n\n- External SRAM interface (phy_clk domain)\n  - sram_we_o: active-high write enable.\n  - sram_re_o: tied high (active) continuously; external memory must satisfy OE/CS timing.\n  - sram_adr_o: word address bus (active-high lines).\n  - sram_data_i/o[31:0]: 32-bit data; no byte enables (full-word writes).\n\n- Interrupts and DMA (clk_i domain externally)\n  - inta_o, intb_o: active-high aggregated interrupt outputs.\n  - dma_req_o[15:0]: active-high per-endpoint request; level/pulsed per hold logic.\n  - dma_ack_i[15:0]: active-high, single-cycle pulse; one pulse acknowledges exactly one 32-bit word.\n\n- Register/field conventions (software-visible)\n  - MAIN_CSR bits are active-high status: [0]=suspend, [1]=mode_hs, [2]=usb_attached, [4:3]=LineState.\n  - MAIN_CSR write bit[5]=1 generates an active-high one-shot (rf_resume_req).\n  - INT_SOURCES bits [8:0] are active-high sticky events; read-to-clear.\n  - UTMI vendor: VStatus[7:0] read as latched; VControl[3:0] written with an active-high VControl_Load pulse generated by write.\n\n- Data/CRC/PID conventions\n  - PID encoding uses active-high bits with upper nibble as ones' complement of lower nibble.\n  - CRC5/CRC16 logic assumes active-high XOR network with LSB-first bit ordering; transmitted CRC16 is ones' complement, low byte first.\n\n- Naming and selection\n  - XcvSelect polarity is 1=FS/0=HS per code usage (verify with PHY documentation if PHY differs).\n  - All match/enable signals (match, dma_*_avail, int_*_set, uc_*_set) are active-high strobes/levels as described above."
    },
    "Parameterization and Configuration": {
        "Generic Parameters (Address Widths, Buffer Sizes)": "Generic Parameters (Address Widths, Buffer Sizes)\n- Core data path widths\n  - UTMI byte interface: 8 bits (DataIn/DataOut[7:0]).\n  - External SSRAM data: 32 bits (sram_data_i/o[31:0]); no byte enables (full-word writes).\n  - Wishbone data: 32 bits (wb_data_i/o[31:0]).\n  - Timestamps/diagnostics: FRM_NAT = 32 bits.\n  - UTMI vendor sideband: VStatus[7:0] (read), VControl[3:0] (write).\n  - Function address: 7 bits.\n\n- Address widths and decode\n  - External SSRAM address width parameter: SSRAM_HADR (module parameter).\n    • External address bus: sram_adr_o[SSRAM_HADR:0].\n    • Wishbone→SSRAM word index: wb_addr_i[SSRAM_HADR+2:2].\n    • Effective packet-buffer memory size (bytes) = 4 × 2^(SSRAM_HADR+1).\n  - RF/WB address width parameter: USBF_UFC_HADR (for wb_addr_i[`USBF_UFC_HADR:0]).\n    • With USBF_TEST_IMPL: region select bit wb_addr_i[17] (0=RF, 1=MA); example build sets SSRAM_HADR=14.\n\n- Endpoint scaling and vectors\n  - Maximum endpoints supported: 16 (EP0..EP15) with fixed 16-wide vectors.\n    • DMA: dma_req_o[15:0], dma_ack_i[15:0].\n    • Live per-EP OR status: int_srca[15:0].\n  - Build-time presence controlled by USBF_HAVE_EPx macros; example build enables EP0..EP3.\n\n- Endpoint CSR fields (sizes)\n  - Max packet size (MPS): 11 bits (csr[10:0], bytes). Used as words via csr[10:2] (P = {3'b000, csr[10:2]}).\n  - User/control toggles: uc_bsel[1:0], uc_dpd[1:0].\n  - Type/state/policy fields reside in csr[27:15] as per design; direction encoded in csr[27:26].\n\n- Buffer descriptor format and limits\n  - Address field width (byte address): [SSRAM_HADR+2:0].\n    • Stored/split as: upper address bits in idin[SSRAM_HADR+2:4]; low nibble [3:0] carried separately (alignment/control).\n  - Size field width: 14 bits at bufX[30:17] (bytes), max 16 KiB per buffer.\n    • Word-capacity view used by DMA: buf0_orig[30:19] (12 bits, words). Max 4096 words (16 KiB).\n  - Default reset value: 32'hFFFF_FFFF (invalid/sentinel) for BUF0/BUF1.\n\n- DMA granularity and counter widths\n  - Granularity: 32-bit words (one ack = one word).\n  - OUT outstanding counter/hold uses word-level width consistent with 12-bit capacity (hold checks |dma_out_cnt[11:2]).\n  - IN prefill counter width consistent with 12-bit word capacity; req/hold logic uses comparisons to buf0_orig[30:19].\n\n- Interrupt masks and RF sources (widths)\n  - RF link-event masks: inta_msk[8:0], intb_msk[8:0].\n  - RF sticky sources: int_srcb[8:0].\n\n- Example configuration (USBF_TEST_IMPL)\n  - SSRAM_HADR = 14 → packet SRAM window size = 4 × 2^(15) = 128 KiB.\n  - wb_addr_i[17] selects RF vs MA region.\n  - Enabled endpoints: EP0..EP3 (others can be compiled out).\n\n- Derived/addressing conventions\n  - Word alignment handled internally (RMW on unaligned RX starts). Descriptor address is a byte address; DMA and memory interface operate on 32-bit word indices.\n  - All size thresholds and holds in DMA logic are word-based; MPS words derived from MPS bytes via csr[10:2].",
        "Build-Time Macros and Options": "Build-Time Macros and Options\n- USBF_TEST_IMPL\n  - Purpose: Selects a larger test/development configuration.\n  - Effects:\n    • Wishbone region select uses wb_addr_i[17] (0=Register File, 1=Memory Array).\n    • Example build sets SSRAM_HADR=14 (128 KiB packet SRAM window).\n    • Expands address width into the core (via USBF_UFC_HADR setting).\n\n- USBF_UFC_HADR\n  - Purpose: Defines the high address index into the core for Wishbone addresses (width of wb_addr_i used by the core RF/MA decode).\n  - Effects: Sizes wb_addr_i[`USBF_UFC_HADR:0] and determines which bits reach RF vs MA logic.\n\n- SSRAM_HADR\n  - Purpose: Sets external synchronous SRAM word-address width.\n  - Effects:\n    • sram_adr_o[SSRAM_HADR:0] width.\n    • Wishbone→SSRAM word index uses wb_addr_i[SSRAM_HADR+2:2].\n    • Effective packet-buffer memory size (bytes) = 4 × 2^(SSRAM_HADR+1). Example: 14 → 128 KiB.\n\n- USBF_HAVE_EPx (endpoint presence)\n  - Purpose: Compile-time inclusion of endpoints EP1..EP15; EP0 is always present.\n  - Constraints: Enabled endpoints must be contiguous (checked at elaboration).\n  - Effects: Sizes active endpoint set; dma_req_o[15:0]/dma_ack_i[15:0] vector bits corresponding to disabled EPs are unused.\n\n- USBF_ASYNC_RESET (optional)\n  - Purpose: Switch selected resets from synchronous to asynchronous in some flops.\n  - Effects:\n    • utmi_if RX/TX handshake flops (RxValid/Active/Error, TxValid) and usbf_wb FSM reset polarity/behavior honor this define.\n    • mem_arb wack_r reset can be async if defined.\n\n- USBF_RF_SEL / USBF_MEM_SEL (address decode helpers)\n  - Purpose: Macros used in usbf_wb to decode RF vs Memory Array region.\n  - Effects: Control which address bit(s) select RF (register) space vs MA (packet SRAM) space; with USBF_TEST_IMPL this is wb_addr_i[17].\n\n- Timing/timeout macro families\n  - USBF_T1_* and USBF_T2_* thresholds (link FSM timing):\n    • Define derived windows such as ~2.5 µs, 100 µs, 0.5 ms, 1.0 ms, 1.2 ms, 3.0/3.125/5/30/50/100 ms for reset/suspend/resume/HS-chirp.\n  - Protocol timeouts (HS/FS):\n    • Macros set IN ACK-wait and OUT activity timeouts (e.g., typical HS≈22 cycles, FS≈36 cycles of phy_clk for rx_ack_to/tx_data_to).\n\n- PID/table constants (header PIDs, CRC polynomials)\n  - Purpose: Provide compile-time constants for PID encodings and CRC modules.\n  - Effects: Do not alter structure but parameterize decoders/checkers; no interface impact.\n\n- Example build summary (as provided)\n  - USBF_TEST_IMPL enabled; SSRAM_HADR=14 (128 KiB); wb_addr_i[17] is RF/MA select.\n  - Endpoints enabled: EP0..EP3 (others compiled out).\n  - Resets synchronous by default (USBF_ASYNC_RESET not defined).\n\nNotes\n- Changing SSRAM_HADR alters external memory size and internal address slicing; software must honor the resulting MA window size.\n- Enabling/disabling endpoints via USBF_HAVE_EPx impacts register map usability for those EP windows and DMA/interrupt aggregation width (vectors remain 16-wide, unused EPs are inert).",
        "Endpoint Presence and Configuration": "Endpoint Presence and Configuration\n- Presence and scaling\n  - EP0 is always present.\n  - Optional endpoints EP1..EP15 are compile-time enabled via USBF_HAVE_EPx; enabled EPs must be contiguous (checked at elaboration).\n  - Vectors are fixed 16-wide: dma_req_o[15:0], dma_ack_i[15:0]; disabled EPs are inert. Example build: EP0..EP3 enabled.\n\n- Register map per endpoint (RF space, wb_addr_i[17]=0)\n  - Base word address for EP n: 0x10 + 4*n\n    • +0: EPn_CSR (R/W)\n    • +1: EPn_INT (R/W, read-to-clear sticky in EP block)\n    • +2: EPn_BUF0 (R/W, 32-bit descriptor)\n    • +3: EPn_BUF1 (R/W, 32-bit descriptor)\n\n- EPn_CSR fields (key configuration)\n  - Direction/type/state/policies:\n    • csr[27:26]: direction (01=IN, 10=OUT); CTRL handled by protocol engine using both directions.\n    • Transfer type, endpoint state (stall/disable), policy bits included in csr[27:15] (see sub-block usbf_ep_rf).\n    • csr[17]: lrg_ok (allow larger-than-MPS on OUT); csr[16]: sml_ok (allow smaller-than-MPS on OUT).\n    • csr[15]: dma_en (enables DMA/ring operation for non-CTRL EPs).\n    • csr[12:11]: tr_fr (HS microframe scheduling for isochronous).\n    • csr[10:0]: max packet size (MPS, bytes).\n  - Software-visible toggles:\n    • uc_bsel[1:0] (CSR MSBs): software buffer-select base/toggle.\n    • uc_dpd[1:0] (CSR MSBs): software data-PID base/toggle policy.\n  - OUT short-packet behavior:\n    • ots_stop (bit13): if set, latches a status when out_to_small occurs.\n\n- Buffer descriptors (EPn_BUF0/BUF1)\n  - 32-bit descriptor; reset default 0xFFFF_FFFF (invalid/sentinel).\n  - Address: byte address in fields [SSRAM_HADR+2:0] (stored across idin upper and low-nibble fields); used by DMA as word-index + byte offset.\n  - Size: bytes in [30:17] (14 bits), max 16 KiB per descriptor; DMA uses a word-capacity view from buf0_orig[30:19] (12 bits, up to 4096 words).\n  - CTRL endpoints: OUT/SETUP use BUF0; IN uses BUF1. Non-CTRL: BUF0/BUF1 selected by uc_bsel with auto-switching on availability.\n\n- Endpoint interrupts (EPn_INT)\n  - Sticky, read-to-clear; sources include: buf0_set, buf1_set, buf0_rl, int_crc16_set, int_to_set, int_upid_set, int_seqerr_set, out_to_small.\n  - Per-EP interrupt enables (iena/ienb, 6 bits each) gate inta/intb at EP level (aggregated in RF).\n\n- DMA per endpoint\n  - Requests: asserted in clk domain when service needed; dma_ack_i pulse (one per 32-bit word) in clk_i domain completes a beat (handshaked across domains).\n  - Convenience live flags (matched EP only): dma_in_buf_sz1 (IN has ≥1 MPS), dma_out_buf_avail (OUT has ≥1 MPS space).\n  - Ring/wrap supported when dma_en=1 (address wraps at buffer-size boundary).\n\n- Matching and live view (core domain)\n  - ep_match asserted in each EP instance when ep_sel matches its programmed endpoint number; OR/select provides live csr, buf0, buf1, dma_* flags for the currently addressed EP.\n\n- Defaults and requirements\n  - On reset: EP CSRs/BUFx default (BUFx=0xFFFF_FFFF; CSR fields cleared). Software must program direction, endpoint number, MPS, DMA enable, and buffer descriptors before use.\n  - Software programs EP windows at 0x10+4*n..+3; global A/B masks determine aggregation onto inta_o/intb_o.\n\n- Behavioral notes\n  - Handshakes (ACK/NAK/STALL/NYET) and data PID sequencing are enforced by usbf_pe using CSR/policy and buffer state.\n  - For HS, PING/NYET and isochronous scheduling (tr_fr) are observed where applicable.",
        "Address Split Configuration": "Address Split Configuration\n- Wishbone region split (top-level)\n  - Address space is divided into two regions:\n    • RF (Register File/control/status) and MA (Memory Array: external SSRAM packet buffer).\n  - Decode uses USBF_RF_SEL/USBF_MEM_SEL; with USBF_TEST_IMPL the region select bit is wb_addr_i[17]:\n    • wb_addr_i[17] = 0 → RF region\n    • wb_addr_i[17] = 1 → MA region\n  - Wishbone port is 32-bit, word-aligned; new requests are accepted only in IDLE (single outstanding transaction).\n\n- RF region address mapping (word addressing)\n  - The RF block uses adr[8:2] (word index). Byte addresses = 4 × word_index.\n  - Global registers (word addresses):\n    • 0x00: MAIN_CSR/CTRL (R; W bit5 = resume pulse)\n    • 0x01: FUNC_ADDR (R/W, 7-bit device address)\n    • 0x02: INT_MASKS A/B (R/W)\n    • 0x03: INT_SOURCES (R; read-to-clear RF stickies)\n    • 0x04: FRM_NAT (R)\n    • 0x05: UTMI_VENDOR (R/W, read status / write control + strobe)\n  - Per-endpoint windows (EPn, n=0..15), base word address = 0x10 + 4*n:\n    • +0: EPn_CSR (R/W)\n    • +1: EPn_INT (R/W; read-to-clear in EP block)\n    • +2: EPn_BUF0 (R/W)\n    • +3: EPn_BUF1 (R/W)\n  - Software-visible summary: RF word index N maps to byte address 4×N on Wishbone.\n\n- Memory Array (MA) address mapping (external SSRAM)\n  - Selected when wb_addr_i[17] = 1 (with USBF_TEST_IMPL).\n  - Word-aligned, 32-bit accesses only (no byte enables). ACK returned on mem_arb grant/ack.\n  - The effective SSRAM word index taken from Wishbone: wb_addr_i[SSRAM_HADR+2:2].\n  - External address bus to SSRAM: sram_adr_o[SSRAM_HADR:0].\n  - Effective MA window size (bytes) = 4 × 2^(SSRAM_HADR+1).\n    • Example: SSRAM_HADR=14 → 128 KiB MA window.\n\n- Descriptor/address split inside endpoint buffers\n  - Endpoint buffer descriptors are 32-bit values with split address fields:\n    • Upper word-aligned address bits are written via idin[SSRAM_HADR+2:4].\n    • Low nibble idin[3:0] carries the lower address/align bits or control (preserved/updated per PE rules).\n  - Size field stored in descriptor bits [30:17] (bytes). DMA uses the corresponding word-capacity view from buf0_orig[30:19].\n\n- Alignment and RMW behavior\n  - All RF and MA accesses are 32-bit word-aligned over Wishbone.\n  - The RX DMA path performs read-modify-write for unaligned packet starts; TX path is word-prefetched and byte-multiplexed internally.\n\n- Example build (USBF_TEST_IMPL)\n  - wb_addr_i[17] splits RF vs MA; SSRAM_HADR=14; EP0..EP3 enabled.\n  - Within RF: use word indices as above; within MA: wb_addr_i[16:2] form the SSRAM word index (for SSRAM_HADR=14).\n\n- Summary\n  - Region: wb_addr_i[17] → RF(0)/MA(1).\n  - RF: word index adr[8:2] → globals at 0x00..0x05; EPn at 0x10+4*n..+3.\n  - MA: SSRAM index from wb_addr_i[SSRAM_HADR+2:2] drives sram_adr_o[SSRAM_HADR:0].",
        "Timing and Protocol Constants": "Timing and Protocol Constants\n- Link/T1/T2 timing windows (UTMI link-state FSM)\n  - Internal tick basis: ~250 ns ticks aggregated to µs/ms windows.\n  - Derived windows (via USBF_T1_*/USBF_T2_* macros):\n    • T1_gt_2_5_uS: ~2.5 µs (reset/suspend qualification helper)\n    • T1_gt_3_0_mS: ~3.0 ms (idle→suspend in FS; HS observation to RES_SUSP)\n    • T1_gt_5_0_mS: ~5.0 ms (minimum suspend before device-initiated resume)\n    • T2_gt_100_uS: ~100 µs (resume settle and HS suspend observation)\n    • T2_wakeup: ~5 ms (remote-wakeup delay before signaling)\n    • T2_gt_1_0_mS: ~1.0 ms (resume K duration; pre-negotiation)\n    • T2_gt_1_2_mS: ~1.2 ms (HS chirp K window)\n    • me_cnt_100_ms: ~100 ms (attach debounce)\n\n- Speed negotiation and resume/reset constants\n  - HS chirp acceptance: 6 alternating K/J chirps required to enter HS.\n  - Reset detect: SE0 held over qualified T1/T2 windows (FS/HS dependent) triggers RESET state.\n  - Resume signaling: drive K ~1.0 ms; settle ~100 µs before returning to NORMAL.\n\n- Protocol engine timeouts (phy_clk domain)\n  - IN ACK wait timeout (rx_ack_to): HS ≈ 22 cycles; FS ≈ 36 cycles.\n  - OUT activity timeout (tx_data_to): HS/FS thresholds match the above scale.\n\n- SOF/microframe timing capture (frm_nat)\n  - frm_nat[31:0] = {mfm_cnt[3:0], 1'b0, frame_no[10:0], 4'h0, sof_time[11:0]}.\n  - mfm_cnt increments on repeated frame_no (HS microframes); sof_time measures sub-frame duration after SOF.\n\n- UTMI operation and control encodings\n  - OpMode: 2'b00 = Normal; 2'b10 = Disable bit-stuff/NRZI (used during reset/resume/chirp windows).\n  - XcvSelect: 1=FS, 0=HS; TermSel=1 enables FS termination; SuspendM asserted when not suspended (polarity per UTMI).\n\n- USB PID and CRC conventions\n  - PID format: {~pid[3:0], pid[3:0]} (ones' complement upper nibble).\n  - CRC5 (tokens): polynomial x^5 + x^2 + 1; LSB-first; compare against ones' complement from bus.\n  - CRC16 (data): polynomial x^16 + x^15 + x^2 + 1; LSB-first; transmitter sends ones' complement, low byte first.\n  - Receiver residue check: final CRC state equals 16'h800d when initialized to 16'hFFFF and processing payload+CRC bytes.\n\n- Byte/bit ordering and packet structure\n  - All USB streams are LSB-first on the wire (tokens, data, CRCs).\n  - Data packet sequence (TX): DATA PID → payload bytes → CRC16[7:0] then CRC16[15:8] (low byte first).\n  - Zero-length data: permitted; CRC16 still appended after DATA PID.\n\n- Arbitration and bus timing notes\n  - Wishbone ACK: single wb_clk-cycle pulse per completed transfer (registered edge detector).\n  - Memory arbiter W-side pacing: wack pulses every other phy_clk when granted (max one W transfer per two phy_clk cycles while M is idle).\n\nNotes\n- Exact real-time durations depend on phy_clk frequency and the USBF_T1_*/USBF_T2_* macro settings. Values above reflect target windows indicated in the RTL.",
        "Simulation and Debug Options": "Simulation and Debug Options\n- Simulation prints and config checks\n  - Top-level initial block prints enabled endpoints and verifies endpoints are contiguous (build-time configuration sanity check).\n  - usbf_idma includes simulation-only checks that emit warnings when key control signals carry X (unknown) values.\n\n- Status/diagnostic registers for observability\n  - Global MAIN_CSR exposes live link state (suspend, HS/FS mode, attached, line_state) for quick health checks.\n  - FRM_NAT (32-bit) captures SOF-derived timing snapshot for frame/microframe diagnostics.\n  - INT_SOURCES (RF-level) is sticky, read-to-clear (usb_reset, rx_err, attach/detach, suspend start/end, PID/CRC5/NSE errors).\n  - Per-EP INT registers are sticky, read-to-clear; software-selectable routing via per-EP enable masks (iena/ienb) and RF A/B masks to inta_o/intb_o.\n\n- Useful internal debug signals (waveform probes)\n  - Link/PHY (usbf_utmi_if / usbf_utmi_ls): mode_hs, usb_reset, usb_suspend, usb_attached, suspend_clr, drive_k, XcvSelect, TermSel, OpMode, SuspendM.\n  - Protocol layer (usbf_pl): token_valid, frame_no, PID classification, pid_cs_err, crc5_err, rx_data_st/valid/done, crc16_err, match_o, nse_err, out_to_small, int_* strobes (buf0/1_set, to, seqerr, upid, crc16).\n  - Packet assembler (usbf_pa): tx_first, tx_valid, tx_valid_last, rd_next.\n  - DMA bridge (usbf_idma): send_data, idma_done, sizu_c (RX count), mreq/mack/mwe, madr (word addr) — observe RMW on unaligned RX and 2-word TX prefetch.\n  - Register file (usbf_rf): per-EP ep_match, live csr/buf0/buf1 mux for the matched EP, dma_in_buf_sz1, dma_out_buf_avail.\n  - Memory arbiter (usbf_mem_arb): wack every other phy_clk while granted, fixed M-priority selection.\n  - Wishbone front-end (usbf_wb): single-cycle wb_ack_o pulse generation (edge-detector pipeline) for clean bus timing correlation.\n\n- Stimulus/control hooks\n  - UTMI vendor sideband: read VStatus (latched), write VControl[3:0] with automatic VControl_Load pulse — useful for PHY model feature toggles in simulation.\n  - Remote-wakeup: write MAIN_CSR bit[5] to generate a one-shot rf_resume_req into the link FSM (tests resume sequences).\n\n- Error injection and observation\n  - PID/CRC error paths exposed via sticky and per-EP INT bits (pid_cs_err, crc5_err, crc16_err, seqerr, nse_err) to validate error handling.\n  - HS OUT short-packet (out_to_small) flagged; optional ots_stop status latch in EP CSR.\n\n- Recommended simulation configuration\n  - USBF_TEST_IMPL enables a larger address space split (wb_addr_i[17] RF/MA) and example SSRAM_HADR=14 (128 KiB MA) suitable for test benches.\n  - Use usbf_ep_rf_dummy for unimplemented endpoints to keep unused EPs inert with known values.\n\n- Clock/reset/CDC debug notes\n  - Two-domain operation: phy_clk (datapath) and wb_clk (bus). wb_ack_o is generated via a 3-FF edge detector — easy to scope in waveforms.\n  - Optional USBF_ASYNC_RESET changes reset flavor of selected flops; default design uses synchronous reset (simplifies sim timing).\n\n- Throughput/handshake visibility\n  - Observe tx_valid/tx_ready and rd_next to verify byte pacing; for RX, align rx_data_valid with rx_active per decoder pipeline.\n  - Watch dma_req_o/dma_ack_i (per-EP) to correlate DMA service with buffer descriptor updates (buf*_set, buf0_rl).",
        "Configuration Constraints and Dependencies": "Configuration Constraints and Dependencies\n- Build-time macro dependencies\n  - USBF_TEST_IMPL: selects a larger/development configuration; forces RF/MA region select to wb_addr_i[17] and typically sets SSRAM_HADR=14 (128 KiB window). If disabled, RF/MA select and address width must be defined consistently elsewhere.\n  - USBF_UFC_HADR: must match the Wishbone address width driven into the core; controls sizing of wb_addr_i[`USBF_UFC_HADR:0] and RF/MA decode reach.\n  - SSRAM_HADR: must match the external SSRAM address bus width and the system memory map. Effective MA size (bytes) = 4 × 2^(SSRAM_HADR+1). Wishbone address bits [SSRAM_HADR+2:2] are consumed for SSRAM word index.\n  - USBF_HAVE_EPx: endpoint instances EP1..EP15 are compile-time selectable; enabled EPs must be contiguous (checked at elaboration). EP0 is always present.\n  - USBF_ASYNC_RESET: if defined, selected flops honor async reset; default is synchronous reset. Choose consistently across the SoC.\n\n- Clocking and CDC constraints\n  - Two primary clock domains: phy_clk (UTMI/protocol/memory arbiter/RF core view) and wb_clk=clk_i (Wishbone/RF bus view/top-level status).\n  - usbf_wb samples wb_stb_i & wb_cyc_i directly in phy_clk and returns ACK via a 3-FF edge detector into wb_clk; safest when wb_clk == phy_clk or otherwise phase/frequency-aligned and timing-closed. Using unrelated clocks increases CDC risk at the WB request sampler.\n  - RF exports live matched-EP view in phy_clk; bus-visible RF registers operate in wb_clk with one-shot strobes to clk domain (rf_resume_req, utmi_vend_wr). Integrators must respect these one-shots and avoid multi-cycle level assumptions.\n\n- External memory interface dependencies\n  - SSRAM must be synchronous, 32-bit wide; sram_re is tied high; one shared port arbitrated between M (core, fixed priority) and W (Wishbone). Integrators must ensure the memory device tolerates constant read-enable and the chosen timing.\n  - No byte enables on Wishbone or SSRAM path; all accesses are 32-bit word-aligned. Software must perform word-aligned accesses only.\n  - Arbiter gives absolute priority to the M side; W-side throughput is limited to one transfer every two phy_clk cycles while M is idle. System software must tolerate backpressure and non-deterministic W access latency under traffic.\n\n- Address map and decode constraints\n  - With USBF_TEST_IMPL: wb_addr_i[17]=0 selects RF; wb_addr_i[17]=1 selects MA. If changing this policy, update USBF_RF_SEL/USBF_MEM_SEL consistently across usbf_wb and software drivers.\n  - Within RF, word addressing uses adr[8:2]; software must use 32-bit accesses (byte address = 4×word index).\n\n- Endpoint instantiation and usage constraints\n  - Enabled EPs must be contiguous; software must not access windows of disabled EPs. Vectors dma_req_o/dma_ack_i remain 16-wide; bits for disabled EPs are inert.\n  - CTRL endpoint buffer usage is fixed: OUT/SETUP uses BUF0; IN uses BUF1. Non-CTRL endpoints: BUF0/BUF1 selection depends on uc_bsel unless dma_en forces BUF0.\n  - Descriptor validity: 0xFFFF_FFFF denotes invalid/sentinel. Software must provision valid address/size before enabling transfers.\n  - Size fields: descriptor size in bytes uses bits [30:17] (14 bits); buf0_orig capacity for DMA flow control uses [30:19] (12-bit word count). MPS in CSR is 11 bits (bytes). Software must respect these limits.\n  - OUT with DMA assumes host sends full MPS; short packets (HS) set out_to_small and preserve original address on write-back. Policy bits csr[17]=lrg_ok, csr[16]=sml_ok govern acceptance; misconfiguration leads to NACK/NYET.\n\n- Protocol/timing dependencies\n  - All link timing windows (reset/suspend/resume/HS chirp) derive from USBF_T1_* and USBF_T2_* macros and the phy_clk rate (base tick ~250 ns). Integrators must set these macros to match the actual PHY clock.\n  - IN ACK and OUT activity timeouts use HS/FS cycle thresholds (e.g., HS≈22, FS≈36 cycles). If phy_clk changes, retune these constants for spec-compliant windows.\n  - Remote wakeup: allowed only after minimum suspend dwell (~5 ms). Software should assert MAIN_CSR bit[5] accordingly; the core enforces the wakeup delay before signaling.\n\n- Wishbone interface constraints\n  - Classic, single-beat, no byte-selects, no bursts/pipelining. One outstanding transaction; new request sampled only in IDLE. System bus fabric and drivers must comply with WB B.3 classic semantics.\n  - Read data must be sampled by software on wb_ack_o; writes complete on wb_ack_o. There is no ERR/RTY signaling.\n\n- UTMI PHY dependencies\n  - PHY must support UTMI/UTMI+ standard pins: TxValid/TxReady handshake, LineState, XcvSelect, TermSel, SuspendM, OpMode[1:0]. OpMode=2'b10 (disable bit-stuff/NRZI) and SuspendM polarity must be compatible with the chosen PHY.\n  - Vendor sideband (VStatus[7:0], VControl[3:0]/Load) is optional and vendor-specific; using it requires a PHY that implements these pins.\n\n- Software/firmware dependencies\n  - RF global/EP registers reset to zero (descriptors to 0xFFFF_FFFF in EPs). Firmware must program funct_adr, per-EP CSR (direction, number, MPS, dma_en), and buffer descriptors before enabling traffic.\n  - Sticky RF events (INT_SOURCES) are cleared on read; drivers must read-to-clear and use A/B masks to route to inta_o/intb_o as needed.\n  - frm_nat provides diagnostics only; not a timing source.\n\n- Compliance caveats (impacting system-level requirements)\n  - Control-pipe Chapter 9 corner cases and HS Test Modes are not fully enforced/implemented in RTL; full USB-IF certification may require firmware policies and/or RTL changes as noted. Integrators should plan validation accordingly."
    },
    "Module Hierarchy and Integration Notes": {
        "Submodule Overview and Responsibilities": "Submodule Overview and Responsibilities\n- usbf_utmi_if (PHY bridge and link interface)\n  - Registers UTMI RxValid/Active/Error and DataIn to present clean RX to the core; mirrors TxReady.\n  - Drives DataOut/TxValid with SOP preload (tx_first) and end-of-packet guarantee (tx_valid_last).\n  - Delegates line-control and link state to usbf_utmi_ls; exports mode_hs, usb_reset, usb_suspend, usb_attached, suspend_clr.\n  - Accepts resume_req_r and generates proper resume (drive K) sequencing.\n\n- usbf_utmi_ls (UTMI link-state controller)\n  - Detects attach, bus reset, suspend/resume; negotiates High-Speed via FS/HS chirps.\n  - Drives UTMI control pins: XcvSelect, TermSel, SuspendM, OpMode.\n  - Implements timing windows (T1/T2) for reset/suspend/resume/HS chirp; outputs status and a suspend_clr pulse.\n\n- usbf_pl (protocol layer and datapath orchestrator)\n  - Coordinates token/data/handshake processing, PID sequencing, timeouts, and policy enforcement.\n  - Sub-blocks:\n    • usbf_pd: PID decode, TOKEN field capture, CRC5/CRC16 checking, RX data stream with pipeline and residue check.\n    • usbf_pe: Transaction control (IN/OUT/SETUP), handshake selection (ACK/NAK/STALL/NYET), DMA start/stop, descriptor write-back, interrupt/event generation and policy checks.\n    • usbf_pa: Packet assembler for TX (handshake or DATA+CRC16), manages tx_valid/tx_first/tx_valid_last and pacing (rd_next).\n    • usbf_idma: Byte↔word bridge to SSRAM; RX read-modify-write for unaligned starts and flush; TX 2-word prefetch; ring/wrap and simple mreq/mack handshake.\n  - Exposes frm_nat (SOF timing), error/status strobes, and convenience DMA readiness flags.\n\n- usbf_mem_arb (single-port SRAM arbiter)\n  - Fixed-priority mux: M (protocol/DMA) over W (Wishbone). Multiplexes address/data/we to SSRAM; sram_re tied high.\n  - Broadcasts read data to both masters; generates wack pacing pulse for W-side transfers.\n\n- usbf_rf (register file, interrupt/DMA aggregator)\n  - Bus view (wb_clk): global registers (main_csr, function address, masks, sticky RF events, frm_nat, UTMI vendor), per-EP windows (CSR/INT/BUF0/BUF1).\n  - Core view (phy_clk): live matched-EP csr/buf0/buf1 plus dma_in_buf_sz1/dma_out_buf_avail; OR of epX_match to select the active view.\n  - Aggregates per-EP interrupts to inta_o/intb_o via masks; fans out dma_req_o and synchronizes dma_ack_i.\n  - Bridges UTMI vendor sideband (VStatus latch, VControl + Load) and remote-wakeup one-shot (rf_resume_req).\n\n- usbf_wb (Wishbone front-end and RF/MA decoder)\n  - Decodes RF vs memory (MA) region (e.g., wb_addr_i[17] under TEST_IMPL), sequences single transactions to RF or mem_arb.\n  - Generates a clean one-cycle wb_ack_o via a 3-FF edge detector into wb_clk; classic WB B.3 single-beat behavior.\n\n- usbf_ep_rf (per-endpoint register/DMA block)\n  - Holds EP CSR (direction, number, MPS, DMA enable, policy), two buffer descriptors (BUF0/BUF1), and sticky per-EP INTs (read-to-clear).\n  - Manages DMA request/ack handshakes and internal word counters for IN prefill and OUT draining; exposes dma_in_buf_sz1/dma_out_buf_avail.\n  - Gated by ep_match so shared in-band updates (buf*_set, uc_*_set, buf0_rl, int_*_set) affect only the selected EP instance.\n\n- usbf_ep_rf_dummy (stub endpoint)\n  - Tie-off implementation for uninstantiated endpoints: no match/interrupt/DMA; returns fixed defaults (bufx=0xFFFF_FFFF).\n\n- usbf_crc5 (combinational CRC-5 for tokens)\n  - Parallel 11-bit LFSR step for USB ADDR/ENDP (LSB-first); used by the packet decoder.\n\n- usbf_crc16 (combinational CRC-16 for data)\n  - Parallel 8-bit LFSR step (LSB-first, x^16+x^15+x^2+1); used in RX checker and TX assembler.\n\nTop-level glue (usbf_top)\n- Connects UTMI PHY, protocol layer, RF, mem_arb, and Wishbone; drives resets (rst, phy_rst_pad_o), exports susp_o, captures LineState/VStatus, gates resume_req into the link FSM.\n- Ensures clean domain crossings via submodule-specific handshakes and edge detectors.",
        "Hierarchical Connectivity and Interfaces": "Hierarchical Connectivity and Interfaces\n- External interfaces at top level (usbf_top)\n  - Wishbone slave (clk_i domain): wb_addr_i[`USBF_UFC_HADR:0], wb_data_i/o, wb_we_i, wb_stb_i, wb_cyc_i, wb_ack_o → connected to usbf_wb.\n  - UTMI PHY (phy_clk domain): DataIn/Out[7:0], TxValid/Ready, RxValid/Active/Error, XcvSelect, TermSel, SuspendM, OpMode[1:0], LineState[1:0], usb_vbus; vendor VStatus[7:0], VControl[3:0], VControl_Load → connected via usbf_utmi_if (data/control) and usbf_rf (vendor sideband control/status).\n  - External synchronous SRAM: sram_adr_o[SSRAM_HADR:0], sram_data_i/o[31:0], sram_re_o (1), sram_we_o → driven by usbf_mem_arb.\n  - Interrupt outputs: inta_o, intb_o ← aggregated by usbf_rf.\n  - Per-EP DMA vector: dma_req_o[15:0] (from usbf_rf), dma_ack_i[15:0] (to usbf_rf).\n  - Power/link: susp_o (registered usb_suspend in clk_i), resume_req_i (latched to resume_req_r to usbf_utmi_if).\n\n- Core datapath and control interconnect (internal)\n  - UTMI PHY ↔ usbf_utmi_if (phy_clk)\n    • Rx: PHY RxValid/Active/Error/DataIn → registered in utmi_if → rx_valid/active/err/rx_data to usbf_pl.\n    • Tx: usbf_pl tx_data/tx_valid/tx_valid_last/tx_first with TxReady from PHY → utmi_if → PHY DataOut/TxValid; TxReady mirrored to pl.\n    • Link control: usbf_utmi_ls (inside utmi_if) drives XcvSelect, TermSel, SuspendM, OpMode to PHY; exports mode_hs, usb_reset, usb_suspend, usb_attached, suspend_clr to top/RF.\n    • Remote wake: resume_req_r from top → utmi_if → drive_k generation towards PHY.\n  - Protocol layer (usbf_pl) ↔ Memory (usbf_mem_arb M-side) (phy_clk)\n    • M master: madr[SSRAM_HADR:0], mdout[31:0], mwe, mreq; mdin[31:0], mack from mem_arb.\n    • usbf_mem_arb multiplexes M vs W to external SSRAM; read data broadcast back to mdin and wdout.\n  - Wishbone (usbf_wb) ↔ RF and Memory (clk_i for wb, phy_clk for FSM)\n    • RF path: rf_re/rf_we pulses and rf_dout (from usbf_wb) → usbf_rf; rf_din (from usbf_rf) → usbf_wb → wb_data_o.\n    • Memory path (W-side): wadr/wdin/wwe/wreq (from usbf_wb) → usbf_mem_arb; wdout/wack (from mem_arb) → usbf_wb; wb_ack_o generated via 3-FF edge detector in wb_clk.\n    • Region decode: addr bit (e.g., wb_addr_i[17] under TEST_IMPL) selects RF (0) vs MA (1).\n  - Register file (usbf_rf) ↔ Protocol layer (core view, phy_clk)\n    • From RF to PL: live matched-EP csr[31:0], buf0[31:0], buf1[31:0], dma_in_buf_sz1, dma_out_buf_avail.\n    • From PL to RF: idin[31:0] write-back bus and strobes (buf0_set, buf1_set, uc_bsel_set, uc_dpd_set, buf0_rl) gated by ep_match.\n    • Event/interrupts: PL int_* strobes feed EP blocks via RF; RF aggregates per-EP inta/intb and RF-level stickies to inta_o/intb_o.\n  - RF (bus view, clk_i) ↔ Endpoint register files usbf_ep_rf[n] (both clk and wclk sides)\n    • Address decode: EP window selects ep_n; wclk bus: adr[1:0], re/we, din → EP; dout ← EP.\n    • Core-domain fan-in: ep_sel[3:0] (from PL) to all EPs; ep_match selects which EP’s csr/bufx reflect on RF core view; dma_req from EPs ORed to dma_req_o; dma_ack_i demuxed to EPs.\n  - UTMI vendor sideband (cross-domain)\n    • VStatus[7:0] from PHY captured (phy_clk) and presented to RF (clk_i) for software read.\n    • Writes to UTMI vendor control at RF (clk_i) generate a one-shot to clk domain and drive VControl[3:0]/VControl_Load toward PHY.\n  - Top-level glue/CDC\n    • suspend_clr (phy_clk) clears resume_req_r; susp_o is usb_suspend registered into clk_i.\n    • rf_resume_req (from RF wclk write) one-shot to phy_clk for utmi_if; wb ACK edge synchronized back to wb_clk.\n\n- Arbitration and memory interface\n  - usbf_mem_arb (phy_clk):\n    • Fixed priority: M (PL/IDMA) over W (WB/software).\n    • W-side pacing: wack pulses every other phy_clk when served; sram_re held high; mdout/wdout both reflect sram_din (masters sample on their ack).\n    • SSRAM pins (sram_adr_o, sram_data_i/o, sram_we_o) are driven by the selected master; read data broadcast to both masters.\n\n- Interrupts and DMA connectivity\n  - Per-EP inta/intb from usbf_ep_rf aggregated in usbf_rf with RF-level stickies; outputs to inta_o/intb_o.\n  - dma_req_o[15:0] from usbf_rf (OR of per-EP requests with hold logic); dma_ack_i[15:0] into usbf_rf and synchronized to clk domain for EP counters.\n\n- Addressing and software-visible interfaces (via usbf_wb → usbf_rf)\n  - RF window (wb_addr_i region=0): globals at 0x00..0x05; per-EP windows at 0x10+4*n {CSR, INT, BUF0, BUF1} (word addressing, 32-bit only).\n  - Memory array window (wb_addr_i region=1): wb_addr_i[SSRAM_HADR+2:2] → sram_adr_o[SSRAM_HADR:0] (word-aligned, 32-bit only).\n\n- Clock/reset domains and crossings\n  - phy_clk: UTMI, usbf_pl (pd/pe/pa/idma), usbf_mem_arb M/W select, RF core view, part of usbf_wb FSM.\n  - clk_i (wb_clk): Wishbone-visible usbf_wb regs/ack pipeline, RF bus view, top-level susp_o.\n  - Resets: rst_i drives rst and phy_rst_pad_o; synchronous by default (USBF_ASYNC_RESET optional).\n\nSummary path\n- Host CPU (Wishbone) → usbf_wb → {usbf_rf (RF) | usbf_mem_arb (MA)} → {usbf_ep_rf array | external SSRAM}.\n- UTMI PHY ↔ usbf_utmi_if ↔ usbf_pl ↔ usbf_mem_arb ↔ external SSRAM.\n- usbf_pl ↔ usbf_rf ↔ usbf_ep_rf[n] for endpoint state, descriptors, DMA requests and interrupts.\n- RF aggregates interrupts and vendor sideband; top-level provides resume/suspend glue and status.",
        "CDC Boundaries and Synchronization": "CDC Boundaries and Synchronization\n- Domain partition\n  - phy_clk (phy_clk_pad_i): UTMI interface and link FSM (usbf_utmi_if/usbf_utmi_ls), protocol layer (usbf_pl: pd/pe/pa/idma), memory arbiter (usbf_mem_arb), RF core view, and the usbf_wb transaction FSM side.\n  - wb_clk (clk_i): Wishbone-visible registers and ACK edge-detector (usbf_wb), RF bus view (global and per-EP windows), top-level susp_o.\n  - Resets: rst_i drives rst and phy_rst_pad_o; default synchronous per-domain (USBF_ASYNC_RESET optionally introduces async resets on selected flops).\n\n- Wishbone↔core CDC (usbf_wb)\n  - Request sampling (wb_clk→phy_clk): wb_req_s1 <= (wb_stb_i & wb_cyc_i) is sampled directly in phy_clk without a 2-FF synchronizer. Safe use is with wb_clk == phy_clk (or phase/frequency aligned and timing-closed); otherwise this is a CDC hazard to be mitigated at integration.\n  - ACK return (phy_clk→wb_clk): wb_ack_d is converted to a one-cycle wb_ack_o in wb_clk via a 3-FF edge-detector pipeline (clean pulse per completed transaction).\n  - Read-data timing: rf_din/ma_din are assumed valid when ACK is produced; not explicitly synchronized inside usbf_wb.\n\n- RF bus view (wb_clk) ↔ RF core view (phy_clk)\n  - One-shot strobes wb_clk→phy_clk: rf_resume_req (remote wake) and utmi_vend_wr (UTMI vendor control write) generated in wb_clk and presented as single-cycle pulses in phy_clk.\n  - UTMI vendor control wb_clk→phy_clk: VControl[3:0] latched with utmi_vend_wr and driven to UTMI pins in phy_clk.\n  - UTMI vendor status phy_clk→wb_clk: VStatus[7:0] captured in phy_clk, exposed as a latched copy in wb_clk for software reads.\n  - Link status phy_clk→wb_clk: mode_hs/usb_suspend/usb_attached/line_state exported via MAIN_CSR in wb_clk through RF registers.\n\n- DMA handshake across domains (usbf_rf/usbf_ep_rf)\n  - Request (clk→wclk): dma_req_d (clk) causes a one-shot dma_req_r in wclk when no request/ack is in flight; optional hold logic maintains request across bursts.\n  - Acknowledge (wclk→clk): wclk toggles dma_ack_wr1 per dma_ack; clk samples into r4/r5 to create a one-cycle dma_ack_i pulse; wclk clears toggle on seeing r4.\n  - Result: robust pulse/toggle CDC for per-EP DMA service with sustain/hold controls.\n\n- Top-level glue crossings\n  - resume_req path: software write (wb_clk) raises rf_resume_req → one-shot to phy_clk; top latches to resume_req_r (phy_clk) and clears on suspend_clr (phy_clk) from utmi_if.\n  - Suspend export: usb_suspend (phy_clk) registered into clk_i as susp_o (phy_clk→wb_clk registered copy).\n  - LineState_r and VStatus_r captured in phy_clk and exposed to software via wb_clk RF reads.\n\n- UTMI/PHY interface\n  - UTMI byte/control signals (DataIn/Out, TxValid/Ready, RxValid/Active/Error, LineState, XcvSelect, TermSel, SuspendM, OpMode) are synchronous to phy_clk; no CDC within the core on these paths.\n\n- Memory interface and arbitration\n  - usbf_mem_arb, M and W sides operate in phy_clk (wclk unused); the W-side presented by usbf_wb is already in phy_clk. Read data (sram_din) is broadcast and sampled by masters on their acks.\n\n- Assumptions and integration guidance\n  - Prefer wb_clk == phy_clk for simplest CDC-safe operation. If asynchronous, add proper synchronization for WB request qualification or meet timing constraints to ensure safe sampling.\n  - Treat one-shot/toggle crossings (rf_resume_req, utmi_vend_wr, dma_ack toggle) as pulses across domains; avoid level-sensitive usage.\n  - If enabling USBF_ASYNC_RESET, verify reset polarity/coverage for PHY- and WB-facing flops across both domains.",
        "Reset Distribution and Power-Up": "Reset Distribution and Power-Up\n- Reset sources and domains\n  - Global reset rst_i fans out to both clock domains and to the external PHY reset pad:\n    - phy domain: rst (internal), phy_rst_pad_o (output to UTMI PHY)\n    - wb domain: rst_i used by usbf_wb and RF bus view\n  - Default reset style is synchronous within each domain; defining USBF_ASYNC_RESET enables async resets for selected flops (e.g., some UTMI IF and WB logic).\n\n- Submodule reset behavior\n  - usbf_utmi_if/usbf_utmi_ls (phy_clk):\n    - On reset, link FSM enters POR, selects FS transceiver (XcvSelect=FS), enables FS TermSel, sets OpMode to normal, clears attached/suspend, mode_hs=0.\n    - FSM can re-enter POR when usb_vbus asserts (power/attach gating).\n    - After reset, ATTACH debounce (~100 ms) must complete before usb_attached=1.\n  - usbf_pl (phy_clk): protocol counters and state clear; usbf_pd initializes PID/CRC registers (PID reset=8'hF0, CRC16 cleared on packet start).\n  - usbf_pa/usbf_idma (phy_clk): CRC and DMA pipelines clear; optional async reset if USBF_ASYNC_RESET defined.\n  - usbf_mem_arb (phy_clk): wack_r resets; muxing is combinational; sram_re held high regardless of reset.\n  - usbf_rf (wb_clk and phy_clk views):\n    - Global RF registers clear to 0 (FUNC_ADDR=0, interrupt masks=0, sticky RF events clear, UTMI vendor ctrl=0).\n    - Core-view exports (csr/bufx/dma flags) reflect endpoint defaults after reset.\n  - usbf_ep_rf (wb_clk/phy_clk): per-EP interrupts clear; CSR control/enable bits clear; BUF0/BUF1 and buf0_orig initialize to 32'hFFFF_FFFF (invalid/sentinel); DMA counters reset.\n  - usbf_wb: FSM state resets (active-low, synchronous to phy_clk if USBF_ASYNC_RESET undefined). WB ACK edge-detector pipeline in wb_clk is not explicitly reset (assumes CYC/STB low during reset).\n\n- Power-up sequence (typical)\n  1) Apply rst_i: both domains enter reset; UTMI link FSM enters POR (FS defaults); RF/EP registers initialize.\n  2) Deassert rst_i: utmi_ls transitions POR→ATTACH; with usb_vbus present and after ~100 ms, usb_attached asserts and NORMAL operation begins.\n  3) Software polls MAIN_CSR for {suspend, mode_hs, usb_attached, line_state} and should wait for usb_attached=1 before programming endpoints.\n  4) Software programs FUNC_ADDR, per-EP CSR (direction, MPS, dma_en), and buffer descriptors (not 0xFFFF_FFFF) before enabling traffic; interrupt masks default to 0 and must be enabled explicitly.\n\n- Bus reset (on-the-wire USB reset) handling\n  - utmi_ls detects SE0 over a qualified window and asserts usb_reset (sticky in RF); then performs speed negotiation:\n    - Prepare: OpMode set to disable bit-stuff/NRZI, FS TermSel on, HS xceiver selected.\n    - After ~1 ms, perform chirp K/J counting; enter HS on six chirps, else fall back to FS; return to NORMAL.\n  - Function address auto-reset on bus reset is not enforced in RTL; firmware should set address to 0 after bus reset until SET_ADDRESS completes (per USB Chapter 9).\n\n- Suspend/resume interaction\n  - usb_suspend (phy_clk) is exported as susp_o in wb_clk (registered copy). Remote-wakeup is requested by writing rf_resume_req (wb_clk), which generates a one-shot into phy_clk; utmi_if performs resume K signaling and emits suspend_clr to clear the latched request.\n\n- Integration guidelines\n  - Hold Wishbone CYC/STB low during and immediately after reset to avoid spurious request sampling in usbf_wb.\n  - If wb_clk != phy_clk, ensure rst_i deassertion is phase-safe in each domain, or add domain-local synchronizers when enabling USBF_ASYNC_RESET.\n  - After power-up or bus reset, firmware should: wait for usb_attached, program endpoints/buffers, enable needed interrupt masks, and check RF INT_SOURCES.usb_reset to detect bus reset events.\n  - If used, tie external PHY reset to phy_rst_pad_o and ensure PHY reset/clock stabilization precede reliance on LineState/VStatus.",
        "Memory Arbiter Integration": "Memory Arbiter Integration\n- Role and placement\n  - usbf_mem_arb is the sole arbiter between two initiators and a single-port 32‑bit synchronous SRAM. It lives entirely in the phy_clk domain and directly drives the external SSRAM pins from usbf_top.\n\n- Masters and handshakes\n  - M (USB core/protocol DMA): driven by usbf_pl/usbf_idma via madr[SSRAM_HADR:0] (word address), mdout[31:0] (write data), mwe (write enable), mreq (request); returns mdin[31:0] (read data) and mack.\n  - W (Wishbone/software): driven by usbf_wb via wadr[SSRAM_HADR:0] (word address), wdin[31:0], wwe, wreq; returns wdout[31:0] and wack.\n  - Fixed priority: M always wins. W is selected only when M is idle. Selection holds across the W ack cycle to avoid mid‑cycle switching.\n\n- External SSRAM interface (top-level ports)\n  - Address/data/control: sram_adr_o[SSRAM_HADR:0], sram_data_o[31:0], sram_data_i[31:0], sram_we_o; sram_re_o is tied high (continuous read‑enable).\n  - Read data broadcast: SSRAM read data (sram_data_i) is fanned out to both mdin and wdout; each master must sample only on its ack.\n  - Byte enables: none. All accesses are 32‑bit word‑aligned.\n\n- Addressing and mapping\n  - Word addressing on both masters. For software, wb_addr_i[SSRAM_HADR+2:2] maps to sram_adr_o[SSRAM_HADR:0].\n  - usbf_idma handles sub‑word alignment internally (adr_cb) and presents word addresses (madr) to the arbiter.\n\n- Clocking/CDC expectations\n  - Arbiter and both M/W sides operate in phy_clk. wclk is unused inside usbf_mem_arb.\n  - The W side presented by usbf_wb is already generated in phy_clk (usbf_wb FSM), so there is no additional CDC between WB and the arbiter. WB ACK pulse generation back to wb_clk is handled inside usbf_wb.\n\n- Handshake specifics and throughput\n  - M side: mack is combinational (mack = mreq); the arbiter does not insert wait states for the core. Upstream IDMA logic must time its sampling to actual SSRAM behavior.\n  - W side: wack is a one‑phy_clk‑cycle pulse and, when M is idle and wreq is held, will pulse every other phy_clk (max one accepted W transfer per two cycles). Any M request immediately suppresses W selection and wack.\n\n- Reset and defaults\n  - Synchronous reset (default); only wack_r is registered and reset. Selection and muxing are combinational. sram_re_o remains asserted after reset.\n\n- Performance/latency characteristics\n  - M has zero added arbitration latency (beyond mux). W experiences at least one extra cycle of pacing (wack toggling) plus any stalls due to M priority.\n  - Under heavy USB traffic, W bandwidth is opportunistic and may starve; software must tolerate variable latency and back‑pressure.\n\n- Integration requirements and caveats\n  - SSRAM_HADR must match the external memory depth and the system map; all accesses are 32‑bit word‑aligned (no byte‑selects).\n  - Continuous sram_re_o=1 requires an SSRAM that tolerates permanent read‑enable; if not, add external gating (chip‑enable or RE) at the top level.\n  - Because M mack is immediate, overall read/write timing closure with the real SSRAM must be ensured by meeting timing at the memory pins; no cycle‑stretching is provided by the arbiter.\n  - With fixed priority, there is no fairness; if fairness is required for software bulk moves, schedule accesses during USB idle or extend the arbiter.\n\n- Software access path to memory (via W side)\n  - usbf_wb decodes wb_addr_i[17]=1 (USBF_TEST_IMPL) to MA and issues wreq/wwe/wadr into usbf_mem_arb; data returns on wdout with wack pacing. ACK to Wishbone (wb_ack_o) is generated by a synchronizer in usbf_wb when wack is seen.\n\n- Core DMA path to memory (via M side)\n  - usbf_idma asserts mreq/mwe with madr/mdout for RX/TX moves; mdin provides read data. Alignment (unaligned starts, final partial word flush) and prefetch are handled in usbf_idma; the arbiter simply arbitrates and muxes to the SSRAM pins.",
        "Software Integration Guidelines": "Software Integration Guidelines\n- Clocks, reset, and bring‑up\n  - Operate with two clocks: phy_clk_pad_i (core/UTMI/memory) and clk_i (Wishbone/RF bus view). Best practice: run clk_i == phy_clk_pad_i; otherwise, expect extra CDC latency on WB ACK.\n  - Apply rst_i, then wait for MAIN_CSR.usb_attached=1 (addr 0x00, read) before programming endpoints. MAIN_CSR also reports suspend, HS mode, and UTMI line_state.\n  - After any bus reset (RF INT_SOURCES[8]), firmware must enforce Chapter 9 semantics: set device address back to 0 and re‑run standard enumeration (address is not auto‑cleared by RTL).\n\n- Wishbone address map and access rules\n  - Region select: wb_addr_i[17]=0 → RF (register file), wb_addr_i[17]=1 → MA (shared packet SRAM).\n  - RF addressing is 32‑bit word aligned; RF word index N maps to byte address 4×N (RF uses adr[8:2]).\n  - Single‑beat, classic WB accesses only; one transaction at a time. wb_ack_o pulses one clk_i cycle per completed access; do not pipeline back‑to‑back requests without observing ACK.\n  - Memory (MA) window is 32‑bit word aligned; accesses may be paced by the arbiter when USB core is active. Expect variable latency; no bursts/byte‑selects.\n\n- Global registers (RF, wb_addr[17]=0)\n  - 0x00 MAIN_CSR (R) / CTRL (W one‑shot): read link state; write bit[5]=1 to request remote‑wakeup (rf_resume_req pulse). Only issue when in suspend; core enforces wakeup timing.\n  - 0x01 FUNC_ADDR (R/W): program device address (7b) after SET_ADDRESS status stage.\n  - 0x02 INT_MASKS A/B (R/W): route RF‑level events to inta_o/intb_o.\n  - 0x03 INT_SOURCES (R, read‑to‑clear RF stickies): usb_reset, rx_err, attach/deattach, suspend start/end, pid_cs_err, crc5_err, nse_err. Read to clear after servicing.\n  - 0x04 FRM_NAT (R): SOF/micro‑frame timestamp for diagnostics.\n  - 0x05 UTMI_VENDOR: read VStatus[7:0]; write VControl[3:0] (loads on write) for PHY vendor sideband.\n\n- Per‑endpoint windows (EPn base = 0x10 + 4*n)\n  - +0 CSR (R/W): set direction, endpoint number, MPS, DMA enable, policy bits, and software toggles (uc_bsel/uc_dpd).\n  - +1 INT (R/W, read‑to‑clear in EP block): per‑EP causes such as buf0_set, buf1_set, buf0_rl, crc16_err, timeout, unexpected PID, sequence error, out_to_small.\n  - +2 BUF0 (R/W), +3 BUF1 (R/W): buffer descriptors (address/length). Reset value 0xFFFF_FFFF means “invalid/unallocated”.\n\n- Endpoint configuration sequence (typical)\n  1) Wait for usb_attached=1. Optionally poll mode_hs for HS/FS.\n  2) Program FUNC_ADDR (0x01) after SET_ADDRESS.\n  3) For each EP to enable:\n     - CSR: set direction/type/policy, MPS, and (optionally) DMA enable.\n     - BUF descriptors: write valid buffer address/length (word‑aligned base in MA space; do not use 0xFFFF_FFFF).\n     - Clear EP INT by reading +1, then enable desired IRQs via system‑level masking (route to inta_o/intb_o using 0x02) and/or software ISR.\n  4) For CTRL EP0, ensure firmware enforces Chapter 9 (always accept SETUP, proper status stage, halt clear/data toggle rules), as the RTL does not hard‑enforce all nuances.\n\n- Buffer management and DMA\n  - Control vs DMA mode:\n    • Non‑DMA/control: firmware may update BUF descriptors per transfer; the core writes back sizes/addresses as it consumes/produces data.\n    • DMA mode (CSR.dma_en=1): core uses BUF0 for DMA path. Program BUF0 only; BUF1 is typically unused by DMA endpoints.\n  - IN (device→host): core may send ZLP if MPS=0 or per policy. Watch EP INT buf*_set/rl and timeout (IN ACK wait).\n  - OUT (host→device): HS short packet triggers out_to_small; descriptor write‑back preserves original address and logs received size. Handle sequence/CRC errors via INT.\n  - Data alignment: MA is 32‑bit word addressed; the core’s IDMA handles unaligned starts and final partial words. Software must still provide word‑aligned base addresses.\n\n- Memory array (MA) access by software\n  - Use wb_addr[17]=1; wb_addr[SSRAM_HADR+2:2] → sram_adr_o.\n  - Expect stalls while USB core is active; arbiter gives hard priority to the core. For throughput moves (e.g., debug dumps), schedule during USB idle.\n\n- Interrupts and event handling\n  - Top‑level IRQs: inta_o/intb_o are ORs of masked RF stickies (0x02 masks over 0x03 sources) and masked per‑EP causes.\n  - Recommended ISR pattern:\n    1) Read 0x03 to snapshot and clear RF stickies; handle usb_reset (re‑initialize EPs), attach/deattach, suspend transitions, token errors.\n    2) Scan EP windows: read EPn_INT (read‑to‑clear) only for active endpoints to minimize WB traffic.\n    3) For EP buffer events, update software queues and, if needed, re‑arm descriptors (BUFx) before returning.\n\n- Suspend/resume and remote wake\n  - Detect suspend via MAIN_CSR.suspend; susp_o mirrors this on clk_i.\n  - Device‑initiated resume: write 1 to MAIN_CSR bit[5]. The core sequences resume K and self‑clears the request on suspend exit (suspend_clr).\n  - Only issue remote‑wakeup when permitted by USB policy (authorized by host and device configured) and when in suspend.\n\n- UTMI vendor sideband (optional)\n  - Read vendor status at 0x05. To drive vendor control, write lower 4 bits at 0x05; write strobe loads VControl into the PHY.\n\n- Performance and robustness tips\n  - WB is classic, single‑beat. Respect the ACK pulse and avoid assuming fixed latency, especially for MA accesses.\n  - The memory arbiter is fixed‑priority (core over WB); software MA bandwidth is opportunistic and may starve under heavy USB traffic.\n  - If wb_clk ≠ phy_clk, expect extra cycles for WB ACK due to CDC; avoid tight polling loops with hard timeouts.\n  - Use FRM_NAT for timing/debug (SOF cadence, microframe timing). Useful to correlate with ISR or throughput measurements.\n\n- Compliance caveats (firmware responsibilities)\n  - Enforce control pipe rules: SETUP must always be accepted and override halt; ensure DATA0 re‑init after halt clear; handle over‑length control OUT with proper STALL semantics; implement HS Test Modes externally if required.\n  - Ensure device address is set to 0 on bus reset and follow SET_ADDRESS timing per USB 2.0.\n\n- Integration of dma_req_o/dma_ack_i (system‑level DMA)\n  - The core exposes per‑EP dma_req_o and accepts dma_ack_i for system‑level coordination (if used). If not integrating a system DMA arbiter, tie dma_ack_i to 0 and rely on internal IDMA.\n\n- Debugging checklist\n  - On no‑traffic: check usb_attached, line_state, and mode_hs; verify FUNC_ADDR and EP CSRs; confirm BUF descriptors != 0xFFFF_FFFF.\n  - On missed IRQs: confirm INT masks (0x02) and that EPn_INT is read to clear.\n  - On memory errors: verify MA addressing (word‑aligned), expect WB stalls, and avoid concurrent heavy WB MA access during isochronous/bulk bursts.",
        "Addressing and Alignment Guidelines": "Addressing and Alignment Guidelines\n- Regions and decoding\n  - Wishbone space is split into two regions (this build):\n    • RF (Register File): wb_addr_i[17] = 0\n    • MA (Memory Array/SSRAM window): wb_addr_i[17] = 1\n  - Note: The region‑select bit is build‑time configurable via macros; use USBF_RF_SEL/USBF_MEM_SEL if different from bit 17 in your build.\n\n- Bus width, alignment, and access granularity\n  - All Wishbone accesses are 32‑bit word‑aligned (no byte‑selects). Only single‑beat classic cycles are supported.\n  - RF window uses word addressing internally (adr[8:2]); RF word index N maps to byte address 4×N. Do not issue byte/halfword cycles.\n  - MA window is also 32‑bit word‑aligned; software must use word addresses (wb_addr_i[SSRAM_HADR+2:2]).\n\n- External SSRAM mapping\n  - Arbiter drives sram_adr_o[SSRAM_HADR:0] with the word address; sram_re_o is tied high; sram_we_o qualifies writes.\n  - Read data (sram_data_i) is broadcast to both masters; each master must sample only on its acknowledge.\n  - Effective buffer memory size (bytes) = 4 × 2^(SSRAM_HADR+1) (word addressing with an extra alignment bit in the byte‑address view).\n\n- Buffer descriptors (EPn_BUF0/BUF1) addressing and size\n  - Each BUF descriptor holds an address and a size field. The address is treated as a byte address in the core domain and is split by the DMA engine as:\n    • Word address: adr_cw = adr[SSRAM_HADR+2:2]\n    • Byte offset within first word: adr_cb = adr[2:0]\n  - Recommended: program buffer base addresses word‑aligned (adr[2:0]=3'b000). The core can handle unaligned starts (RX uses read‑modify‑write; TX prefetches and muxes bytes), but alignment avoids extra cycles.\n  - Sizes are programmed in bytes; internally the core also derives word counts. Max Packet Size (CSR[10:0]) is in bytes; the core uses P = CSR[10:2] (words) for DMA accounting. Sizes need not be multiples of 4; partial last words are handled.\n  - Bounds: ensure BUF address+size lie within the MA window (SSRAM_HADR depth). 0xFFFF_FFFF in BUF registers denotes “invalid/unallocated.”\n\n- Endpoint register window layout (RF region)\n  - EPn base = 0x10 + 4×n (word addresses). At each base:\n    • +0: CSR (R/W)\n    • +1: INT (R/W; read‑to‑clear)\n    • +2: BUF0 (R/W)\n    • +3: BUF1 (R/W)\n  - All are 32‑bit word accesses; undefined behavior on sub‑word cycles.\n\n- Memory Array (MA) addressing from software\n  - Software MA accesses use wb_addr_i[SSRAM_HADR+2:2] → sram_adr_o; data is 32‑bit words. Expect variable latency: the arbiter gives hard priority to the USB core.\n  - For throughput copies, schedule MA reads/writes during USB idle to reduce stalls.\n\n- DMA/address handling inside the core (for context)\n  - RX path: unaligned starts are supported via an initial read‑modify‑write; the last partial word is flushed after rx_data_done.\n  - TX path: a 2‑word ping‑pong read buffer sustains streaming; byte selection across words is automatic based on the starting offset.\n\n- Practical recommendations\n  - Use word‑aligned buffer bases to minimize RMW overhead and simplify software bookkeeping.\n  - Choose buffer sizes to match or exceed endpoint MPS; non‑multiples of 4 are fine.\n  - Keep MA addresses within the configured SSRAM depth (match SSRAM_HADR) and avoid overlapping buffers unless intentionally sharing.\n  - In RF space, always compute byte addresses as 4×word_index; do not assume contiguous byte addressing for registers.",
        "Remote Wakeup Integration": "Remote Wakeup Integration\n- Control sources and domains\n  - Software request (WB domain): write 1 to MAIN_CSR bit[5] at RF address 0x00 to generate rf_resume_req (one-shot pulse in wb_clk). This pulse is safely transferred into phy_clk and latched at the top level as resume_req_r.\n  - External/system request (top-level pin): resume_req_i (async to clk_i) is also accepted as a remote-wakeup request source (implementation combines with resume_req_r to drive the link FSM).\n  - Clear mechanism: the link block (usbf_utmi_ls) emits suspend_clr (phy_clk) on suspend exit; top-level clears resume_req_r on this pulse so stale requests do not persist after a completed resume.\n\n- Link FSM behavior and timing (phy_clk)\n  - Preconditions: device must be in suspend (usb_suspend=1), and the suspend dwell must exceed ~5 ms (T1_gt_5_0_mS) before a device-initiated resume is honored.\n  - Sequence after a valid request:\n    1) RESUME_REQUEST: waits an additional wakeup delay (~5 ms, T2_wakeup) per spec guidance.\n    2) RESUME_SIG: drives K on the UTMI lines (drive_k=1) for ~1 ms (T2_gt_1_0_mS). During this, OpMode=2'b10 (disable bit-stuff/NRZI) and FS termination is enabled as required for resume signaling.\n    3) RESUME: releases K, waits for SE0 (bus handshake), restores normal OpMode (2'b00), and (if previously HS) reselects HS xceiver and disables FS termination.\n    4) RESUME_WAIT: settles for ~100 µs, then returns to NORMAL; usb_suspend deasserts here and suspend_clr pulses.\n  - Host-initiated resume is also supported (K detected in SUSPEND), independent of remote-wakeup requests.\n\n- Software usage model (recommended)\n  - Only request remote wake when: MAIN_CSR.suspend=1, the host has enabled remote wake for the function, and policy allows it. Do not assert requests while not suspended.\n  - Initiation steps:\n    1) Poll MAIN_CSR.suspend (0x00 bit[0]) or use susp_o to detect suspend.\n    2) Write 1 to MAIN_CSR bit[5] to request remote wake (one-shot).\n    3) Observe resume progress via MAIN_CSR.suspend clearing and/or RF INT_SOURCES.suspend_end (0x03 bit[4], read-to-clear).\n  - If a request is written when not suspended, it is latched and will be acted upon only when/if the core enters suspend and meets the dwell requirement; firmware should avoid this by gating on MAIN_CSR.suspend.\n\n- Clock-domain and handshake details\n  - rf_resume_req (wb_clk) is converted to a single-cycle pulse in phy_clk and then latched (resume_req_r) so the link FSM cannot miss it.\n  - The latch is cleared by suspend_clr, guaranteeing a clean request lifecycle across domains and power states.\n\n- UTMI/PHY side effects during resume\n  - While signaling resume, the block drives K (drive_k), sets OpMode to \"disable bit-stuff/NRZI\" (2'b10), enables FS termination, and gates TxValid as needed; normal UTMI operation (2'b00) resumes after the handshake and settle.\n\n- Observability and interrupts\n  - Use MAIN_CSR fields to monitor suspend and speed mode; use RF INT_SOURCES to detect suspend_start/end and usb_reset around resume windows.\n  - There is no dedicated \"remote-wakeup completed\" bit; use suspend_end (0x03 bit[4]) as the completion indicator.\n\n- Compliance notes and responsibilities\n  - The core enforces key timing windows (≥5 ms suspend dwell before initiating, ~1 ms K assertion, ~100 µs settle). Firmware must ensure remote wake is used only when the host has enabled it and the function is configured, and must not violate the USB 2.0 policy constraints (e.g., spacing to previous bus activity).\n  - The request is a one-shot; repeated writes are harmless but unnecessary while a request is in progress.",
        "Verification and Bring-Up Notes": "Verification and Bring-Up Notes\n- Clocks, reset, and CDC\n  - Two domains: phy_clk (UTMI/core/memory) and clk_i (Wishbone/RF bus view). Prefer clk_i == phy_clk for initial bring-up; otherwise expect extra ACK latency and add CDC checks on WB paths.\n  - Hold Wishbone CYC/STB low during and immediately after rst_i. Resets are synchronous by default; some flops (e.g., WB ACK pipeline) are not explicitly reset—assume benign with requests idle.\n  - sram_re_o is tied high; verify the external SRAM model tolerates permanent RE.\n\n- UTMI PHY integration checklist\n  - After reset, link defaults to FS with FS termination enabled. Verify 100 ms ATTACH debounce (usb_attached rises after ~100 ms with VBUS present).\n  - Bus reset detection: SE0 window -> usb_reset asserts; then HS chirp sequence (count six K/J toggles) or fallback to FS. Check XcvSelect/TermSel/OpMode sequencing.\n  - Resume: host-initiated K in suspend or device-initiated (rf_resume_req). Verify timing windows (~5 ms dwell, ~1 ms K, ~100 µs settle) and suspend_clr pulse.\n  - Tx handshakes: confirm tx_first pre-load and tx_valid_last produce clean UTMI TxValid/TxReady behavior at SOP and final beat.\n\n- Wishbone interface bring-up\n  - Classic, single-beat WB. One transaction at a time; wb_ack_o is a one-cycle pulse in clk_i.\n  - RF region: wb_addr[17]=0, word-aligned; MA region: wb_addr[17]=1, word-aligned. Do not issue byte/halfword cycles.\n  - With wb_clk != phy_clk, verify the WB ACK synchronizer path (3-FF pipeline) and spacing states (W0/W1/W2) avoid back-to-back hazards.\n\n- Memory arbiter behavior\n  - Fixed priority: M (core) preempts W (WB). When M active, W wack is suppressed; when served, wack pulses every other phy_clk (pace WB master accordingly).\n  - M mack is combinational (mack=mreq). Ensure the SSRAM model/data-valid timing aligns with upstream IDMA sampling.\n\n- Endpoint programming and buffers\n  - EPn windows: CSR/INT/BUF0/BUF1 at word addresses (base 0x10+4*n). BUF registers reset to 0xFFFF_FFFF (invalid); program valid base/size before enabling traffic.\n  - Recommended: word-align buffer bases; the core handles unaligned starts via RMW (RX) and byte mux (TX) but with extra cycles.\n  - DMA mode uses BUF0 on DMA endpoints; control/non-DMA may use BUF0/BUF1 ping-pong per CSR/uc_bsel.\n\n- Minimal bring-up flow (host enumeration)\n  1) Apply rst_i; wait for MAIN_CSR.usb_attached=1. Optionally detect HS via MAIN_CSR.mode_hs.\n  2) Firmware implements EP0 control pipe. Program FUNC_ADDR (0x01) after SET_ADDRESS status stage (address not auto-cleared on bus reset).\n  3) Program EP CSRs (direction, MPS, policy) and BUF descriptors. Enable desired interrupts (0x02 masks, plus per-EP INT handling).\n  4) Service per-EP INT (read-to-clear); update/arm BUF descriptors as transfers complete.\n\n- Debug/observability aids\n  - MAIN_CSR (0x00): suspend, HS/FS, attached, line_state.\n  - INT_SOURCES (0x03, R2C): usb_reset, suspend_start/end, attach/deattach, token/CRC errors.\n  - FRM_NAT (0x04): SOF/microframe timestamp—useful for performance and timing correlation.\n  - UTMI vendor (0x05): read VStatus, write VControl[3:0] with auto-load strobe.\n\n- Recommended testbench components\n  - UTMI PHY BFM: drive LineState (J/K/SE0), RxValid/Active/Error, and respond to TxValid/TxReady; model HS chirp exchange.\n  - Wishbone BFM: single-beat classic cycles with backpressure capability to verify WB FSM and ACK timing.\n  - SSRAM model: synchronous, 32‑bit, tolerant of continuous RE; parameterized depth to match SSRAM_HADR.\n\n- Directed tests (bring-up and protocol)\n  - Attach debounce: assert usb_vbus and J line; expect usb_attached after ~100 ms.\n  - Bus reset: SE0 window -> usb_reset; then HS negotiation success (6 chirps) and fallback path; verify mode_hs.\n  - Suspend/resume: idle-long -> usb_suspend; host K resume; device remote-wakeup via MAIN_CSR bit[5] with required delays.\n  - Token/CRC paths: good/bad PID complement, CRC5/CRC16 errors; check INT sources and per-EP INT read-to-clear.\n  - IN/OUT data paths: aligned/unaligned buffers, ZLP, HS PING/NYET, OUT short (out_to_small) handling and descriptor write-back preservation.\n  - Memory arbitration: sustained protocol traffic plus WB MA accesses to observe W-side pacing/starvation behavior.\n\n- Assertions and coverage ideas\n  - UTMI: TxValid implies eventual TxReady; tx_valid_last must not be dropped before acceptance.\n  - Link FSM: cover all states (POR/ATTACH/NORMAL/RESET/SUSPEND/RESUME_* and SPEED_NEG variants) and legal transitions.\n  - WB: one ACK per request; no ACK without request; RF fast path ACK in W0; MA ACK only on ma_ack.\n  - IDMA: no lost word on unaligned RX; final partial write occurs on rx_data_done; TX prefetch maintains byte continuity across word boundaries.\n\n- Known limitations impacting verification (firmware workarounds)\n  - EP0 Chapter 9 semantics not fully enforced in hardware (e.g., SETUP always-accept, halt override, DATA0 re-init, overlength control OUT STALL). Exercise via firmware and tests.\n  - Device address not auto-cleared on USB reset—verify firmware sets address to 0 on reset.\n  - HS Test Modes (Test_J/K/SE0_NAK/Test_Packet) not implemented; exclude from compliance scope or model externally.\n\n- Common pitfalls\n  - Misaligned WB accesses to RF/MA (only 32-bit words supported).\n  - Expecting fair WB access under heavy USB load (arbiter is hard-priority to core).\n  - Issuing remote wake when not in suspend or before 5 ms dwell—request will be ignored or delayed.\n  - Assuming immediate WB ACK for MA reads—depends on mem_arb grant and ma_ack.\n\n- Bring-up checklist (quick)\n  - Clocks stable (clk_i, phy_clk), rst_i applied, WB idle during reset.\n  - UTMI: XcvSelect/TermSel/OpMode sane after reset; VBUS present; LineState transitions visible.\n  - MAIN_CSR readable; write 0x05 vendor control toggles VControl_Load; INT_SOURCES read-to-clear works.\n  - EP0 CSR/BUF programmed; MA window accessible; simple loopback/echo on BULK endpoints passes with CRC/timeout INTs clean.",
        "Known Limitations and Best Practices": "Known Limitations and Best Practices\n- Protocol and compliance gaps (firmware responsibilities)\n  - EP0 Chapter 9 not fully enforced in RTL: SETUP is not guaranteed always-accept/override-halt; overlength control OUT may NAK instead of STALL; no automatic DATA0 re-init or auto-clear of halt on CLEAR_FEATURE; Status-stage/ZLP behavior not hard-guaranteed.\n  - Device address may not auto-reset to 0 on bus reset; firmware must force address=0 on reset and re-enumerate.\n  - USB 2.0 HS Test Modes (Test_J/K/SE0_NAK/Test_Packet) are not implemented.\n  - ISO/INT enforcement (bInterval, high-bandwidth multiple transactions per microframe) is not hard-checked in RTL.\n\n- Bus and memory subsystem constraints\n  - Wishbone: classic, single-beat only; no pipelining/bursts/byte-selects. All accesses must be 32-bit word-aligned.\n  - Memory arbiter is fixed-priority to the USB core (M). Software (W) memory accesses can starve under load; expect variable WB latency.\n  - mack=mreq (combinational). No wait-state insertion for core accesses; meet SSRAM timing externally. sram_re_o is tied high—use an SSRAM tolerant of continuous RE or gate at top level.\n\n- Clocking and CDC assumptions\n  - Design assumes wb_clk == phy_clk for simplest operation. With independent clocks, the WB request sampling (to phy) and ACK return synchronizer add latency and require timing closure; avoid tight polling loops with fixed cycle budgets.\n  - Only minimal CDC is used on the WB path; validate in your environment or align clocks during bring-up.\n\n- Addressing and alignment\n  - RF and MA spaces are 32-bit word addressed. Program endpoint BUF descriptors with word-aligned bases; the core tolerates unaligned starts via RMW (RX) and byte-muxing (TX) but with extra cycles.\n  - Ensure SSRAM_HADR matches your external memory depth; keep all buffers within the MA window. 0xFFFF_FFFF in BUF registers means invalid/unallocated.\n\n- Remote wakeup usage\n  - Core enforces timing (~5 ms suspend dwell, ~1 ms K, ~100 µs settle) but does not verify host authorization. Firmware must only assert MAIN_CSR bit[5] when suspended and host-enabled.\n\n- Integration hooks and unused paths\n  - dma_req_o/dma_ack_i are available for system-level DMA arbitration; if unused, tie dma_ack_i low and rely on the internal IDMA.\n  - UTMI SuspendM polarity can vary across PHYs—verify against your PHY datasheet.\n\n- Best practices (integration and firmware)\n  - Run clk_i == phy_clk for first silicon bring-up; add CDC assertions and relax timeouts if clocks differ.\n  - Schedule software MA moves during USB idle to mitigate W-side starvation.\n  - Always program EP CSRs and BUF descriptors (not 0xFFFF_FFFF) before enabling traffic; word-align bases and size ≥ MPS where practical.\n  - On USB reset: clear/rehydrate EP state, set address=0, and rebuild descriptors/masks.\n  - Use FRM_NAT (0x04) to correlate timing/throughput; read INT_SOURCES (0x03) early in ISRs to clear stickies.\n  - Validate SSRAM timing with continuous RE, or add external gating if needed.\n  - Add system-level tests for HS negotiation (six chirps), suspend/resume (host/device-initiated), and error paths (PID/CRC/timeout/sequence).\n\n- Known behavioral nuances\n  - WB ACK: RF reads/writes ACK in the fast path (W0); MA reads/writes ACK only on ma_ack. Don’t assume fixed latency.\n  - OUT short in HS (out_to_small) preserves original address and writes received count; software must consume/report appropriately.\n  - No fairness in mem_arb; do not rely on periodic WB access under sustained USB streaming."
    }
}